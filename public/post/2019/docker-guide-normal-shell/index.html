<!doctype html>
<html lang="zh-CN"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <title>薛尧的博客</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="" />

    
    
    
    <link rel="stylesheet" href="../../../css/theme.min.css">

    
    
    
    
    <link rel="stylesheet" href="../../../css/custom.min.css">
    

    
</head>
<body>
        <div id="content" class="mx-auto"><header class="container mt-sm-5 mt-4 mb-4 mt-xs-1">
    <div class="row">
        
        <div class="col-sm-4 col-12 text-sm-right text-center pt-sm-4">
            <a href="../../../" class="text-decoration-none">
                <img id="home-image" class="rounded-circle"
                    
                        src="https://ueyao.github.io/image-hosting/blog/avatar.png"
                    
                />
            </a>
        </div>
        <div class="col-sm-8 col-12 text-sm-left text-center">
        
            <h2 class="m-0 mb-2 mt-4">
                <a href="../../../" class="text-decoration-none">
                    
                        薛尧
                    
                </a>
            </h2>
            <p class="text-muted mb-1">
                
                    Java Developer | Short Video Creator
                
            </p>
            <ul id="nav-links" class="list-inline mb-2">
                
                
                    <li class="list-inline-item">
                        <a class="badge badge-white " href="../../../about/" title="关于">关于</a>
                    </li>
                
                    <li class="list-inline-item">
                        <a class="badge badge-white " href="../../../post/" title="文章">文章</a>
                    </li>
                
                    <li class="list-inline-item">
                        <a class="badge badge-white " href="../../../categories/" title="分类">分类</a>
                    </li>
                
            </ul>
            <ul id="nav-social" class="list-inline">
                
                    <li class="list-inline-item mr-3">
                        <a href="http://github.com/flowstone" target="_blank">
                            <i class="fab fa-github fa-1x text-muted"></i>
                        </a>
                    </li>
                
                    <li class="list-inline-item mr-3">
                        <a href="mailto:xueyao.me#gmail.com" target="_blank">
                            <i class="fas fa-at fa-1x text-muted"></i>
                        </a>
                    </li>
                
            </ul>
        </div>
    </div>
    <hr />
</header>
<div class="container">
    <div class="pl-sm-2">
        <div class="mb-3">
            <h3 class="mb-0">Docker入门-常用命令</h3>
            
            <small class="text-muted">发布于 2019-08-14</small>
        </div>

        <article>
            <h2 id="docker镜像操作">Docker镜像操作</h2>
<p>Docker运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker会从镜像仓库下载该镜像。</p>
<h3 id="获取镜像">获取镜像</h3>
<p>从Docker镜像仓库获取镜像的命令是docker pull。其命令格式为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker pull <span style="color:#f92672">[</span>选项<span style="color:#f92672">][</span>Docker Registry地址<span style="color:#f92672">[</span>:端口号<span style="color:#f92672">]</span>/<span style="color:#f92672">]</span>仓库名<span style="color:#f92672">[</span>:标签<span style="color:#f92672">]</span>
</span></span></code></pre></div><p>具体的选项可以通过docker pull &ndash;help命令看到，这里我们说一下镜像名称的格式。Docker镜像仓库地址：地址的格式一般是&lt;域名/IP&gt;[:端口号]。默认地址是Docker Hub。仓库名：如之前所说，这里的仓库名是两段式名称，即&lt;用户名&gt;/&lt;软件名&gt;。对于Docker Hub,如果不给出用户名，则默认为library,也就是官方镜像。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker pull ubuntu:16.04
</span></span></code></pre></div><p>上面的命令中没有给出Docker镜像仓库地址，因此将会从Docker Hub获取镜像。而镜像名称是ubuntu:16.04,因此将会获取官方镜像library/ubuntu仓库中标签为16.04的镜像。</p>
<h3 id="运行镜像">运行镜像</h3>
<p>有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的ubuntu:16.04为例，如果我们打算启动里面的bash并且进行交互式操作的话，可以执行下面的命令。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker run -it --rm ubuntu:16.04 bash
</span></span></code></pre></div><p>-it:这是两个参数，一个是-i:交互式操作，一个是-t终端。</p>
<p>&ndash;rm:这个参数是说容器退出后随之将其删除</p>
<p>ubuntu:16.04:这是指用ubuntu:16.04镜像为基础来启动容器。</p>
<p>bash:放在镜像名后的是命令，这里我们希望有个交互式shell,因此用的是bash。</p>
<p>最后我们通过exit退出了这个容器。</p>
<h3 id="列出镜像">列出镜像</h3>
<p>要想列出已经下载下来的镜像，可以使用docker image ls命令。列表包含了仓库名、标签、镜像ID、创建时间以及所占用的空间。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker image ls
</span></span></code></pre></div><p>查看镜像、容器、数据卷所占用的空间。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker system df
</span></span></code></pre></div><p>仓库名、标签均为<!-- raw HTML omitted -->的镜像称为虚悬镜像(dangling image)，显示这类镜像</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker image ls -f dangling<span style="color:#f92672">=</span>true
</span></span></code></pre></div><p>一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker image prune
</span></span></code></pre></div><h3 id="删除本地镜像">删除本地镜像</h3>
<p>如果要删除本地的镜像，可以使用docker image rm命令，其格式为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker image rm <span style="color:#f92672">[</span>选项<span style="color:#f92672">]</span> &lt;镜像1&gt;<span style="color:#f92672">[</span>&lt;镜像2&gt;...<span style="color:#f92672">]</span>
</span></span></code></pre></div><p>其中，&lt;镜像&gt;可以是镜像短ID、镜像长ID、镜像名或者镜像摘要。</p>
<p>使用docker image ls -q来配置docker image rm，这样可以批量删除希望删除的镜像。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker image rm <span style="color:#66d9ef">$(</span>docker image ls -q ubuntu<span style="color:#66d9ef">)</span> <span style="color:#75715e">#删除所有仓库名为redis的镜像</span>
</span></span></code></pre></div><p>或者删除所有在ubuntu:16.04之前的镜像：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker image rm <span style="color:#66d9ef">$(</span>docker image ls -q -f before<span style="color:#f92672">=</span>ubuntu:16.04<span style="color:#66d9ef">)</span>
</span></span></code></pre></div><h2 id="docker容器操作">Docker容器操作</h2>
<p>容器是独立运行的一个或一组应该，以及它们运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统(提供了运行态环境和其他系统环境)和跑在上面的应用。</p>
<h3 id="启动容器">启动容器</h3>
<p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态(stopped)的容器重新启动。</p>
<p>因为Docker的容器实是轻量级的，用户可以随时删除和新创建容器。</p>
<h4 id="新建并启动">新建并启动</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker run
</span></span></code></pre></div><p>输出一个“Hello World”，之后终止容器。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker run ubuntu:16.04 /bin/echo <span style="color:#e6db74">&#34;Hello world&#34;</span>
</span></span></code></pre></div><h4 id="启动已终止容器">启动已终止容器</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker container start 或者 docker start
</span></span></code></pre></div><p>启动一个bash终端，允许用户进行交互。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker run -t -i ubuntu:16.04 /bin/bash
</span></span></code></pre></div><p>-t 让Docker分配一个伪终端并绑定到容器的标准输入上，-i则让容器的标准输入保持打开。当利用docker run来创建容器时，Docker在后台运行的标准操作包括：</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个ip地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<h3 id="后台运行">后台运行</h3>
<p>很多时间，需要让Docker在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加-d参数来实现。</p>
<p>如果不使用-d参数运行容器，比如docker run hello-world会把日志打印在控制台。
如果使用-d参数运行容器，比如docker run -d hello-world不会输出日志，只会打印容器id(输出结果可以用docker logs查看)；</p>
<p>注：容器是否会长久运行，是和docker run指定的命令有关，和-d参数无关。</p>
<h3 id="停止运行的容器">停止运行的容器</h3>
<p>可以使用docker container stop来终止一个运行中的容器。终止状态的容器可以用docker container ls -a 命令看到。处于终止状态的容器，可以通过docker container start命令来重新启动。此处，docker container restart命令会将一个运行态的容器终止，处于再重新启动它。</p>
<h3 id="进入容器">进入容器</h3>
<p>在使用-d参数时，容器启动后进入后台，某些时候需要进入容器进行操作，使用docker exec命令可以进入到运行中。</p>
<p>exec命令 -i -t参数</p>
<p>docker exec后边可以跟多个参数，这是主要说明 -i -t参数。
只用-i参数时，由于没有分配伪终端，界面没有我们熟悉的Linux命令提示符，但命令执行结果仍然可以返回。当-i -t参数一起使用时，则可以看到我们熟悉的Linux命令提示符。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker exec -it 容器id /bin/bash
</span></span></code></pre></div><h3 id="导出和导入容器">导出和导入容器</h3>
<h4 id="导出容器">导出容器</h4>
<p>如果要导出本地某个容器，可以使用docker export命令。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker export 容器ID&gt;导出文件名.tar
</span></span></code></pre></div><h4 id="导入容器">导入容器</h4>
<p>可以使用docker import从容器快照文件中再导入为镜像</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cat 导出文件名.tar|docker import - 镜像用户/镜像名：镜像版本
</span></span></code></pre></div><p>此外，也可以通过指定URL或者某个目录来导入</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker import http://study.163.com/image.tgz example/imagerepo
</span></span></code></pre></div><h3 id="删除容器">删除容器</h3>
<h4 id="删除容器-1">删除容器</h4>
<p>可以使用docker container rm来删除一个处于终止状态的容器</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker container rm ubuntu:16:04
</span></span></code></pre></div><p>如果要删除一个运行中的容器，可以添加-f参数。Docker会发送SIGKILL信号给容器。</p>
<h4 id="清楚所有处于终止状态的容器">清楚所有处于终止状态的容器</h4>
<p>用docker container ls -a 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可以会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。</p>
<pre tabindex="0"><code>docker container prune
</code></pre>
        </article>
    </div>

    <div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "xie-yao-de-bo-ke" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

            </div>
        </div><footer class="text-center pb-1">
    <small class="text-muted">
        
        &copy; Copyright 2024
        
        |
        <a href="https://beian.miit.gov.cn/" target="_blank">苏ICP备14012079号</a>
        <br />
        由 <a href="https://gohugo.io/" target="_blank">Hugo</a> 强力驱动
        | 主题 <a href="https://github.com/austingebauer/devise" target="_blank">Devise</a>
        <br />

    </small>
</footer></body>
</html>
