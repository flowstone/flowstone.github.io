<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docker on 薛尧的博客</title>
    <link>http://localhost:1313/categories/docker/</link>
    <description>Recent content in Docker on 薛尧的博客</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <copyright>&amp;copy; Copyright 2024</copyright>
    <lastBuildDate>Wed, 21 Aug 2019 12:35:15 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/categories/docker/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Docker进阶-快速扩容</title>
      <link>http://localhost:1313/post/2019/docker-guide-expansion/</link>
      <pubDate>Wed, 21 Aug 2019 12:35:15 +0000</pubDate>
      <guid>http://localhost:1313/post/2019/docker-guide-expansion/</guid>
      <description>&lt;h2 id=&#34;1命令方式&#34;&gt;1、命令方式&lt;/h2&gt;&#xA;&lt;p&gt;在创建好的Swarm集群中运行nginx服务，并使用&amp;ndash;replicas参数指定启动的副本数。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;docker service create --replicas &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; -p 80:80 --name nginx nginx:latest&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;或者&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-ba&#34; data-lang=&#34;ba&#34;&gt;docker service create -p 80:80 --name nginx nginx:latest&#xA;docker service scale nginx=3&#xA;docker service ls #查看副本情况&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;2portainer方式&#34;&gt;2、portainer方式&lt;/h2&gt;&#xA;&lt;p&gt;可以使用portainer的方式在web界面上创建服务并指定副本数，同时可以随时动态增减副本数。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://ueyao.github.io/image-hosting/blog/2019/8/docker-rapid-expansion-01.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Docker入门-docker compose的使用</title>
      <link>http://localhost:1313/post/2019/docker-guide-compose-use/</link>
      <pubDate>Mon, 19 Aug 2019 12:33:56 +0000</pubDate>
      <guid>http://localhost:1313/post/2019/docker-guide-compose-use/</guid>
      <description>&lt;h2 id=&#34;compose简介&#34;&gt;Compose简介&lt;/h2&gt;&#xA;&lt;p&gt;Compose项目是Docker官方的开源项目，负责实现对Docker容器集群的快速编排。其代码目前在https://github.com/docker/compose 上开源。&lt;/p&gt;&#xA;&lt;p&gt;Compose定位是定义和运行多个Docker容器的应用，其前身是开源项目Fig。&lt;/p&gt;&#xA;&lt;p&gt;通过前面内容的介绍，我们知道使用一个Dockerfile模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某任务的情况。例如要实现一个Web项目,除了Web服务容器本身，往往还需要加上后端的数据库服务容器，甚至还包括负载均衡容器等。&lt;/p&gt;&#xA;&lt;p&gt;Compose恰好满足了这样的需求。它允许用户通过一个单独的docker-compose.yml模板文件来定义一组相关联的应用容器为一个项目(project)。&lt;/p&gt;&#xA;&lt;p&gt;Compose中有两个重要的概念：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;服务(service):一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。&lt;/li&gt;&#xA;&lt;li&gt;项目(project):由一组关联的应用容器组成的一个完整业务单元。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Compose的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。&lt;/p&gt;&#xA;&lt;p&gt;Compose项目由Python编写，实现上调用了Docker服务提供的API来对容器进行管理。&lt;/p&gt;&#xA;&lt;h2 id=&#34;安装和卸载&#34;&gt;安装和卸载&lt;/h2&gt;&#xA;&lt;p&gt;Compose支持Linux、macOS、Windows10三大平台。&lt;/p&gt;&#xA;&lt;p&gt;Compose可以通过Python的包管理工具pip进行安装，也可以直接下载编译好的二进制文件使用，甚至能够直接在Docker容器中运行。&lt;/p&gt;&#xA;&lt;p&gt;Docker for Mac、Docker for Windows自带docker-compose二进制文件，安装Docker之后可以直接使用。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;docker-compose --version&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Linux系统需要单独使用二进制或者pip方式进行安装。&lt;/p&gt;&#xA;&lt;h3 id=&#34;linux安装docker-compose&#34;&gt;Linux安装docker-compose&lt;/h3&gt;&#xA;&lt;h4 id=&#34;二进制包&#34;&gt;二进制包&lt;/h4&gt;&#xA;&lt;p&gt;在Linux上的安装十分简单，从官方GitHub Release处直接下载编译好的二进制文件即可。例如，在Linux64位系统上直接下载对应的二进制包。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo curl -L &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;https://github.com/docker/compose/releases/download/1.24.1/docker-compose-&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;uname -s&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;uname -m&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt; -o /usr/local/bin/docker-compose&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo chmod +x /usr/local/bin/docker-compose  &lt;span style=&#34;color:#75715e&#34;&gt;#赋予可执行权限&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://ueyao.github.io/image-hosting/blog/2019/8/docker-compose-01.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;pip安装&#34;&gt;PIP安装&lt;/h4&gt;&#xA;&lt;p&gt;如果您计算机的架构是ARM(例如，树莓派),建议使用pip安装。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo pip install -U docker-compose&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;&#xA;&lt;p&gt;场景：最常见的项目是web网站，一般的web网站都会依赖第三方提供的服务(比如：DB和cache),我们拿dubbo-admin进行讲解(dubbo-admin依赖zookeeper)。&lt;/p&gt;&#xA;&lt;h3 id=&#34;compose构建dubbo-admin服务&#34;&gt;Compose构建dubbo-admin服务&lt;/h3&gt;&#xA;&lt;p&gt;从github上获取dubbo-admin的master分支源码&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git clone -b master https://github.com/apache/incubator-dubbo-ops.git&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;修改admin中的application配置，把zookeeper地址改为zookeeper://zookeeper:2181&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://ueyao.github.io/image-hosting/blog/2019/8/docker-compose-02.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;使用maven进行编译打包&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mvn clean package -Dmaven.test.skip&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;true&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://ueyao.github.io/image-hosting/blog/2019/8/docker-compose-03.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;在dubbo-admin目录下编写Dockerfile文件，内容为&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# FROM,表示使用JDK8环境为基础镜像，如果镜像不是本地会从DockerHub进行下载&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;FROM openjdk:8-jdk-alpine&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 作者&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;MAINTAINER Simon&amp;lt;xueyao.me@gmail.com&amp;gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;VOLUME /tmp&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# ADD,拷贝文件并且重命名&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ADD ./target/dubbo-admin-0.0.1-SNAPSHOT.jar app.jar&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# ENTRYPOINT,为了缩短Tomcat启动时间，添加java.security.egd的系统属性指向/dev/urandom作为ENTRYPOINT&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ENTRYPOINT &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;java&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;-Djava.security.egd=file:/dev/./urandom&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;-jar&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/app.jar&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用docker build -t dubbo-admin:1.0 .命令进行构建。&#xA;&lt;img src=&#34;https://ueyao.github.io/image-hosting/blog/2019/8/docker-compose-04.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Docker入门-数据挂载</title>
      <link>http://localhost:1313/post/2019/docker-guide-data-mount/</link>
      <pubDate>Sun, 18 Aug 2019 12:31:57 +0000</pubDate>
      <guid>http://localhost:1313/post/2019/docker-guide-data-mount/</guid>
      <description>&lt;h2 id=&#34;docker数据管理&#34;&gt;Docker数据管理&lt;/h2&gt;&#xA;&lt;p&gt;在容器中管理数据主要有两种方式：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;数据卷(Volumes)&lt;/li&gt;&#xA;&lt;li&gt;挂载主机目录(Bind mounts)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://ueyao.github.io/image-hosting/blog/2019/8/docker-data-mount-01.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;数据卷&#34;&gt;数据卷&lt;/h3&gt;&#xA;&lt;p&gt;数据卷是一个可供一个或多个容器使用的特殊目录，它绕过UFS,可以提供很多有用的特性：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;数据卷可以在容器之间共享和重用&lt;/li&gt;&#xA;&lt;li&gt;对数据卷的修改会立马生效&lt;/li&gt;&#xA;&lt;li&gt;对数据卷的更新，不会影响镜像&lt;/li&gt;&#xA;&lt;li&gt;数据卷默认会一直存在，即使容器被删除&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;注意： 数据卷的使用，类似于Linux下对目录或文件进行mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的数据卷。&lt;/p&gt;&#xA;&lt;p&gt;Docker中提供了两种挂载方式，-v和-mount&lt;/p&gt;&#xA;&lt;p&gt;Docker新用户应该选择 &amp;ndash;mount参数&lt;/p&gt;&#xA;&lt;p&gt;经验丰富的Docker使用者对-v或者&amp;ndash;volume已经很熟悉了，但是推荐使用-mount参数。&lt;/p&gt;&#xA;&lt;p&gt;创建一个数据卷&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;docker volume create my-volume&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;查看指定数据卷的信息&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;docker volume inspect my-volume&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://ueyao.github.io/image-hosting/blog/2019/8/docker-data-mount-02.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;启动一个挂载数据卷的容器：&lt;/p&gt;&#xA;&lt;p&gt;在用docker run命令的时候，使用&amp;ndash;mount标记来将数据卷挂载到容器里。&lt;/p&gt;&#xA;&lt;p&gt;创建一个名为session-web的容器，并加载一个数据卷到容器中的/webapp目录。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 方法一&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;docker run --name session-web -d -p 8888:8080 --mount source&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;my-volume,target&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;/webapp  session-web:latest&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 方法二&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;docker run --name session-web -d -p 8888:8080 -v my-volume:/webapp     session-web:latest&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;删除数据卷&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;docker volume rm my-volume&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;数据卷是被设计用来持久化数据的，它的生命周期独立于容器，Docker不会在容器被删除后自动删除数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷。&#xA;如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用docker rm -v这个命令。&lt;/p&gt;&#xA;&lt;p&gt;无主的数据卷可能会占据很多空间，要清理请使用以下命令&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;docker volume prune&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;挂载主机目录&#34;&gt;挂载主机目录&lt;/h3&gt;&#xA;&lt;p&gt;使用&amp;ndash;mount标记可以指定挂载一个本地主机的目录到容器中去&lt;/p&gt;</description>
    </item>
    <item>
      <title>Docker入门-搭建docker私有仓库</title>
      <link>http://localhost:1313/post/2019/docker-guide-private-repository/</link>
      <pubDate>Fri, 16 Aug 2019 12:30:55 +0000</pubDate>
      <guid>http://localhost:1313/post/2019/docker-guide-private-repository/</guid>
      <description>&lt;h2 id=&#34;docker-hub&#34;&gt;Docker Hub&lt;/h2&gt;&#xA;&lt;p&gt;目前Docker官方维护了一个公共仓库Docker Hub，其中已经包括了数量超过15000个镜像。大部分需求都可以通过在Docker Hub中直接下载镜像来使用。&lt;/p&gt;&#xA;&lt;h3 id=&#34;注册登录&#34;&gt;注册登录&lt;/h3&gt;&#xA;&lt;p&gt;可以在https://hub.docker.com 免费注册一个Docker账号。在命令行执行docker login输入用户名及密码来完成在命令行界面登记Docker Hub。你可以通过docker logout退出登录。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://ueyao.github.io/image-hosting/blog/2019/8/docker-repository-01.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;拉取镜像&#34;&gt;拉取镜像&lt;/h3&gt;&#xA;&lt;p&gt;可以通过docker search命令来查找官方仓库中的镜像，并利用docker pull命令来将它下载到本地。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://ueyao.github.io/image-hosting/blog/2019/8/docker-repository-02.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://ueyao.github.io/image-hosting/blog/2019/8/docker-repository-03.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;推送镜像&#34;&gt;推送镜像&lt;/h3&gt;&#xA;&lt;p&gt;用户也可以在登录后通过docker push命令来将自己的镜像推送到Docker Hub。&lt;/p&gt;&#xA;&lt;p&gt;修改本地镜像的名字为账号名/镜像名&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://ueyao.github.io/image-hosting/blog/2019/8/docker-repository-04.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;上传镜像到公共仓库&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://ueyao.github.io/image-hosting/blog/2019/8/docker-repository-05.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;上传过后，查看远程公共仓库&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://ueyao.github.io/image-hosting/blog/2019/8/docker-repository-06.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;私有仓库&#34;&gt;私有仓库&lt;/h2&gt;&#xA;&lt;p&gt;有时候使用Docker Hub这样的公共仓库可能不方便，用户可以创建一个本地仓库供私人使用。比如，基于公司内部项目构建的镜像。&lt;/p&gt;&#xA;&lt;p&gt;docker-registry是官方提供的工具，可以用于构建私有的镜像仓库。&lt;/p&gt;&#xA;&lt;p&gt;安装运行docker-registry&lt;/p&gt;&#xA;&lt;p&gt;可以通过获取官方registry镜像来运行。默认情况下，仓库会被创建在容器的/var/lib/registry目录下。可以通过-v参数来将镜像文件存放在本地的指定路径。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;docker run --name registry -d  -p 5000:5000 --restart&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;always  -v /opt/data/registry:/var/lib/registry registry&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://ueyao.github.io/image-hosting/blog/2019/8/docker-repository-07.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;在私有仓库上传、搜索、下载镜像&lt;/p&gt;&#xA;&lt;p&gt;创建好私有仓库之后，就可以使用docker tag来标记一个镜像，然后推送它到仓库。先在本机查看已有的镜像。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;docker image ls&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用docker tag将session-web:latest这个镜像标记为127.0.0.1:5000/session-web:latest格式为docker tag IMAGE[:TAG][REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;docker tag session-web:latest 127.0.0.1:5000/session-web:latest&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用docker push上传标记的镜像&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;docker push 127.0.0.1:5000/session-web:latest&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://ueyao.github.io/image-hosting/blog/2019/8/docker-repository-08.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;用curl查看仓库中的镜像&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;curl 127.0.0.1:5000/v2/_catlog&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果可以看到{&amp;ldquo;repositories&amp;rdquo;:[&amp;ldquo;session-web&amp;rdquo;]},表明镜像已经被成功上传了。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Docker入门-构建第一个Java程序</title>
      <link>http://localhost:1313/post/2019/docker-guide-first-java-program/</link>
      <pubDate>Fri, 16 Aug 2019 12:29:49 +0000</pubDate>
      <guid>http://localhost:1313/post/2019/docker-guide-first-java-program/</guid>
      <description>&lt;h3 id=&#34;docker入门-构建第一个java程序&#34;&gt;Docker入门-构建第一个Java程序&lt;/h3&gt;&#xA;&lt;h4 id=&#34;定制镜像&#34;&gt;定制镜像&lt;/h4&gt;&#xA;&lt;p&gt;准备一个没有第三方依赖的java web项目，可以参考示例maven结构项目：&lt;/p&gt;&#xA;&lt;p&gt;session-web.war&lt;/p&gt;&#xA;&lt;p&gt;把该war上传到安装有docker软件的服务器上宿主目录下。在同级目录创建Dockerfile&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;touch Dockerfile&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;vim Dockerfile&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;按照前面文章所学的Dockerfile定制镜像知识来编写Dockerfile文件内容如下：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-dockerfile&#34; data-lang=&#34;dockerfile&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 基础镜像使用&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;tomcat:7.0.88-jre8&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; tomcat:7.0.88-jre8&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 作者&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;MAINTAINER&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; simon &amp;lt;xueyao.me@gmail.com&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 定义环境变量&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ENV&lt;/span&gt; TOMCAT_BASE /usr/local/tomcat&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 复制war包&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;COPY&lt;/span&gt; ./session-web.war $TOMCAT_BASE/webapps/&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;执行构建：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;docker bulid -t session-web:latest .&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果构建成功，则会显示构建的分层信息及结果。&lt;/p&gt;&#xA;&lt;p&gt;查看tomcat构建结果&lt;/p&gt;&#xA;&lt;p&gt;构建成功后使用docker images命令查看本地是否有该镜像&lt;/p&gt;&#xA;&lt;p&gt;查看是否有该镜像&lt;/p&gt;&#xA;&lt;h4 id=&#34;运行镜像&#34;&gt;运行镜像&lt;/h4&gt;&#xA;&lt;p&gt;镜像制作好之后我们就要把它运行起来&lt;/p&gt;&#xA;&lt;p&gt;docker run &amp;ndash;name session-web -d -p 8888:8080 session-web:latest&lt;/p&gt;&#xA;&lt;p&gt;启动后使用netstat -na|grep 8888 验证端口是否是在监听状态&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://ueyao.github.io/image-hosting/blog/2019/docker-run-container-port.png&#34; alt=&#34;查看服务端口有没有启动&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;浏览器中访问http://ip:8888/session-web/user/login&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://ueyao.github.io/image-hosting/blog/2019/docker-run-java-result.png&#34; alt=&#34;最终效果图&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;本文中war包在此仓库下https://github.com/flowstone/blog-example-code&lt;/p&gt;</description>
    </item>
    <item>
      <title>Docker入门-常用命令</title>
      <link>http://localhost:1313/post/2019/docker-guide-normal-shell/</link>
      <pubDate>Wed, 14 Aug 2019 12:29:00 +0000</pubDate>
      <guid>http://localhost:1313/post/2019/docker-guide-normal-shell/</guid>
      <description>&lt;h2 id=&#34;docker镜像操作&#34;&gt;Docker镜像操作&lt;/h2&gt;&#xA;&lt;p&gt;Docker运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker会从镜像仓库下载该镜像。&lt;/p&gt;&#xA;&lt;h3 id=&#34;获取镜像&#34;&gt;获取镜像&lt;/h3&gt;&#xA;&lt;p&gt;从Docker镜像仓库获取镜像的命令是docker pull。其命令格式为：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;docker pull &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;选项&lt;span style=&#34;color:#f92672&#34;&gt;][&lt;/span&gt;Docker Registry地址&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;:端口号&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;/&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;仓库名&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;:标签&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;具体的选项可以通过docker pull &amp;ndash;help命令看到，这里我们说一下镜像名称的格式。Docker镜像仓库地址：地址的格式一般是&amp;lt;域名/IP&amp;gt;[:端口号]。默认地址是Docker Hub。仓库名：如之前所说，这里的仓库名是两段式名称，即&amp;lt;用户名&amp;gt;/&amp;lt;软件名&amp;gt;。对于Docker Hub,如果不给出用户名，则默认为library,也就是官方镜像。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;docker pull ubuntu:16.04&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的命令中没有给出Docker镜像仓库地址，因此将会从Docker Hub获取镜像。而镜像名称是ubuntu:16.04,因此将会获取官方镜像library/ubuntu仓库中标签为16.04的镜像。&lt;/p&gt;&#xA;&lt;h3 id=&#34;运行镜像&#34;&gt;运行镜像&lt;/h3&gt;&#xA;&lt;p&gt;有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的ubuntu:16.04为例，如果我们打算启动里面的bash并且进行交互式操作的话，可以执行下面的命令。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;docker run -it --rm ubuntu:16.04 bash&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;-it:这是两个参数，一个是-i:交互式操作，一个是-t终端。&lt;/p&gt;&#xA;&lt;p&gt;&amp;ndash;rm:这个参数是说容器退出后随之将其删除&lt;/p&gt;&#xA;&lt;p&gt;ubuntu:16.04:这是指用ubuntu:16.04镜像为基础来启动容器。&lt;/p&gt;&#xA;&lt;p&gt;bash:放在镜像名后的是命令，这里我们希望有个交互式shell,因此用的是bash。&lt;/p&gt;&#xA;&lt;p&gt;最后我们通过exit退出了这个容器。&lt;/p&gt;&#xA;&lt;h3 id=&#34;列出镜像&#34;&gt;列出镜像&lt;/h3&gt;&#xA;&lt;p&gt;要想列出已经下载下来的镜像，可以使用docker image ls命令。列表包含了仓库名、标签、镜像ID、创建时间以及所占用的空间。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;docker image ls&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;查看镜像、容器、数据卷所占用的空间。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;docker system df&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;仓库名、标签均为&lt;!-- raw HTML omitted --&gt;的镜像称为虚悬镜像(dangling image)，显示这类镜像&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;docker image ls -f dangling&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;true&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;docker image prune&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;删除本地镜像&#34;&gt;删除本地镜像&lt;/h3&gt;&#xA;&lt;p&gt;如果要删除本地的镜像，可以使用docker image rm命令，其格式为：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;docker image rm &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;选项&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &amp;lt;镜像1&amp;gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;&amp;lt;镜像2&amp;gt;...&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中，&amp;lt;镜像&amp;gt;可以是镜像短ID、镜像长ID、镜像名或者镜像摘要。&lt;/p&gt;&#xA;&lt;p&gt;使用docker image ls -q来配置docker image rm，这样可以批量删除希望删除的镜像。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Docker入门-介绍和安装</title>
      <link>http://localhost:1313/post/2019/docker-guide-intro-install/</link>
      <pubDate>Wed, 14 Aug 2019 12:27:50 +0000</pubDate>
      <guid>http://localhost:1313/post/2019/docker-guide-intro-install/</guid>
      <description>&lt;h2 id=&#34;docker容器&#34;&gt;Docker容器&lt;/h2&gt;&#xA;&lt;h3 id=&#34;docker是什么&#34;&gt;Docker是什么&lt;/h3&gt;&#xA;&lt;p&gt;Docker最初是dotCloud公司创建人Solomon Hykes在法国期间发起的一个公司内部项目，它是基于dotCloud公司多年云服务技术的一次革新，并于2013年3月以Apache2.0授权协议开源，主要项目代码在Github上进行维护。Docker项目后来加入了Linux基金会，并成立推动开放容器联盟(OCI).&lt;/p&gt;&#xA;&lt;p&gt;Docker使用Google公司推出的Go语言进行开发实现，基于Linux内核的cgroup,namespace,以及AUFS类的Union FS等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称为容器。&lt;/p&gt;&#xA;&lt;p&gt;Docker在容器的基础上，进行了进一步的封装，从文件系统、网络互联至进程隔离等待，极大的简化了容器的创建和维护。使得Docker技术比虚拟机技术更为轻便、快捷。&lt;/p&gt;&#xA;&lt;h3 id=&#34;docker和传统虚拟机&#34;&gt;Docker和传统虚拟机&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://ueyao.github.io/image-hosting/blog/2019/docker-vm.png&#34; alt=&#34;docker和传统虚拟机比较&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；&lt;/p&gt;&#xA;&lt;p&gt;而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。&lt;/p&gt;&#xA;&lt;h3 id=&#34;为什么要使用docker&#34;&gt;为什么要使用Docker&lt;/h3&gt;&#xA;&lt;h4 id=&#34;docker优势&#34;&gt;Docker优势&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;更高效的利用系统资源&lt;/li&gt;&#xA;&lt;li&gt;更快速的启动时间&lt;/li&gt;&#xA;&lt;li&gt;一致的运行环境&lt;/li&gt;&#xA;&lt;li&gt;持续交付和部署&lt;/li&gt;&#xA;&lt;li&gt;更轻松的迁移&lt;/li&gt;&#xA;&lt;li&gt;更轻松的维护和扩展&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;对比传统虚拟机总结&#34;&gt;对比传统虚拟机总结&lt;/h4&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;特性&lt;/th&gt;&#xA;          &lt;th&gt;容器&lt;/th&gt;&#xA;          &lt;th&gt;虚拟机&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;启动&lt;/td&gt;&#xA;          &lt;td&gt;秒级&lt;/td&gt;&#xA;          &lt;td&gt;分钟级&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;硬盘使用&lt;/td&gt;&#xA;          &lt;td&gt;一般为MB&lt;/td&gt;&#xA;          &lt;td&gt;一般为GB&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;性能&lt;/td&gt;&#xA;          &lt;td&gt;接近原生&lt;/td&gt;&#xA;          &lt;td&gt;较弱&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;系统支持量&lt;/td&gt;&#xA;          &lt;td&gt;单机支持上千个容器&lt;/td&gt;&#xA;          &lt;td&gt;一般几十个&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;docker架构&#34;&gt;Docker架构&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://ueyao.github.io/image-hosting/blog/2019/docker-framework.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;Docker使用客户端-服务器(C/S)架构模式，使用远程API来管理和创建Docker容器。&lt;/p&gt;&#xA;&lt;h3 id=&#34;docker基本概念&#34;&gt;Docker基本概念&lt;/h3&gt;&#xA;&lt;h4 id=&#34;docker镜像&#34;&gt;Docker镜像&lt;/h4&gt;&#xA;&lt;p&gt;我们都知道，操作系统分为内核和用户空间。对于Linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持。而Docker镜像(Image),就相当于是一个root文件系统。比如官方镜像centos:7.6就包含了完整的一套centos7.6最小系统的root文件系统。&lt;/p&gt;&#xA;&lt;p&gt;Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数(如匿名半卷、环境变量、用户等)。镜像不包含任何动态数据，其内容在构建之后也不会被改变。&lt;/p&gt;&#xA;&lt;h4 id=&#34;docker镜像分层存储&#34;&gt;Docker镜像分层存储&lt;/h4&gt;&#xA;&lt;p&gt;因为镜像包含操作系统完整的root文件系统，其体积往往是庞大的，因此在Docker设计时将其设计为分层存储的架构。镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。&lt;/p&gt;&#xA;&lt;p&gt;镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。&lt;/p&gt;&#xA;&lt;p&gt;分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。&lt;/p&gt;&#xA;&lt;h4 id=&#34;docker容器-1&#34;&gt;Docker容器&lt;/h4&gt;&#xA;&lt;p&gt;镜像(Image)和容器(Container)的关系，就像Java中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。&lt;/p&gt;&#xA;&lt;p&gt;前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。&lt;/p&gt;&#xA;&lt;p&gt;容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。&lt;/p&gt;&#xA;&lt;p&gt;按照Docker最佳实践的要求，容器不应该向其存储内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用Volume数据卷、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。&lt;/p&gt;&#xA;&lt;p&gt;数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。&lt;/p&gt;&#xA;&lt;h4 id=&#34;docker仓库&#34;&gt;Docker仓库&lt;/h4&gt;&#xA;&lt;p&gt;镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry就是这样的服务。&lt;/p&gt;&#xA;&lt;p&gt;一个Docker Registry中可以包含多个仓库(Repository)；每个仓库可以包含多个标签(Tag)；每个标签对应一个镜像。&lt;/p&gt;&#xA;&lt;p&gt;通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应软件的各个版本。我们可以通过&amp;lt;仓库名&amp;gt;:&amp;lt;标签&amp;gt;的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以latest作为默认标签。&lt;/p&gt;&#xA;&lt;p&gt;以centos镜像为例，centos是仓库的名字，其内包含有不同的版本标签，如，6.9，7.5。我们可以通过centos:6.9，或者centos:7.5来具体指定所需哪个版本的镜像。如果忽略了标签，比如centos,那将视为centos:latest。&lt;/p&gt;&#xA;&lt;p&gt;仓库名经常以两段式路径形式出现，比如study/nginx，前者往往意味着Docker Registry多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体Docker Registry的软件或服务。&lt;/p&gt;&#xA;&lt;h5 id=&#34;docker-registry公开仓库&#34;&gt;Docker Registry公开仓库&lt;/h5&gt;&#xA;&lt;p&gt;常用的Registry是官方的Docker Hub，这也是默认的Registry。除此以外，还有CoreOS的Quay.io，CoreOS相关的镜像存储在这里；Google的Google Container Registry,Kubernetes的镜像使用的就是这个服务。&lt;/p&gt;&#xA;&lt;p&gt;国内的一些云服务商提供了针对Docker Hub的镜像服务。这些镜像服务被称为加速器。常见的有阿里加速器、DaoCloud加速器等。使用加速器会直接从国内的地址下载Docker Hub的镜像，比直接从Docker Hub下载速度会提高很多。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Docker入门-Dockerfile的使用</title>
      <link>http://localhost:1313/post/2019/docker-guide-dockerfile/</link>
      <pubDate>Wed, 14 Aug 2019 12:26:32 +0000</pubDate>
      <guid>http://localhost:1313/post/2019/docker-guide-dockerfile/</guid>
      <description>&lt;h2 id=&#34;使用dockerfile定制镜像&#34;&gt;使用Dockerfile定制镜像&lt;/h2&gt;&#xA;&lt;p&gt;镜像的定制实际上就是定制每一层所添加的配置、文件。我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，这个脚本就是Dockerfile。&lt;/p&gt;&#xA;&lt;p&gt;Dockerfile是一个文本文件，其内包含了一条条的指令，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。&lt;/p&gt;&#xA;&lt;p&gt;接下来我们以官方nginx镜像为例，使用Dockerfile来定制。&lt;/p&gt;&#xA;&lt;p&gt;在一个空白目录中，建立一个文本文件，并命名为Dockerfile:&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mkdir mynginx&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cd mynginx&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;touch Dockerfile&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其内容为：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;FROM nginx&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;RUN echo &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;lt;h1&amp;gt; Hello,Docker!&amp;lt;/h1&amp;gt;&amp;#39;&lt;/span&gt; &amp;gt;/usr/share/nginx/html/index.html&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个Dockerfile很简单，一共就两行。涉及到了两条指令，FROM和RUN。&lt;/p&gt;&#xA;&lt;h3 id=&#34;from指定基础镜像&#34;&gt;FROM指定基础镜像&lt;/h3&gt;&#xA;&lt;p&gt;所谓定制镜像，一定是以一个镜像为基础，在其上进行定制。基础镜像是必须指定的，而FROM就是指定基础镜像，因此一个Dockerfile中FROM是必备的指令，并且必须是第一条指令。在Docker Hub上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如nginx、redis、mysql、tomcat等；可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。&lt;/p&gt;&#xA;&lt;p&gt;如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如ubuntu、debian、centos、alpine等，这些操作系统的软件库为我们提供了更广阔的扩展空间。&lt;/p&gt;&#xA;&lt;p&gt;除了选择现有镜像为基础镜像外，Docker还存在一个特殊的镜像，名为scratch。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;FROM scratch&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果你以scratch为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。&lt;/p&gt;&#xA;&lt;p&gt;对于Linux下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接FROM scratch会让镜像体积更加小巧。使用Go语言开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为Go是特别适应容器微服务架构的语言的原因之一。&lt;/p&gt;&#xA;&lt;h3 id=&#34;run执行命令&#34;&gt;RUN执行命令&lt;/h3&gt;&#xA;&lt;p&gt;RUN指令是用来执行命令行命令的。由于命令行的强大能力，RUN指令在定制镜像时是最常用的指令之一。其格式有两种：&lt;/p&gt;&#xA;&lt;p&gt;shell格式：RUN &amp;lt;命令&amp;gt;&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;RUN echo &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;lt;h1&amp;gt;Hello,Docker~&amp;lt;/h1&amp;gt;&amp;#39;&lt;/span&gt; &amp;gt; /usr/share/nginx/html/index.html&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;exec格式： RUN [&amp;ldquo;可执行文件&amp;rdquo;,“参数1”,“参数2”]&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;RUN make -C /usr/src/redis&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;RUN make -C /usr/src/redis install&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面我们利用Dockerfile定制了nginx镜像，现在我们明白了这个Dockerfile的内容，接下来我们来构建这个镜像。&lt;/p&gt;&#xA;&lt;p&gt;在Dockerfile文件所在目录执行:&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;docker build -t nginx:v3 .&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在Step2中，RUN指令启动了一个容器782d25b7c611,执行了所要示的命令，并最后提交了这一层ba38ff665f57,随后删除了所用到的这个容器782d25b7c611。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://ueyao.github.io/image-hosting/blog/20191214172011541.png&#34; alt=&#34;dockerfile构建&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;启动构建的Nginx&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;docker run --name nginx-test -p 8081:80 -d nginx:v3&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如图所示&lt;/p&gt;</description>
    </item>
    <item>
      <title>Docker进阶-容器监控cAdvisor&#43;InfluxDB&#43;Granfana</title>
      <link>http://localhost:1313/post/2019/docker-guide-cadvisor-influxdb-granfan/</link>
      <pubDate>Fri, 07 Sep 2018 12:13:29 +0000</pubDate>
      <guid>http://localhost:1313/post/2019/docker-guide-cadvisor-influxdb-granfan/</guid>
      <description>&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;&#xA;&lt;p&gt;前面文章介绍使用docker compose组合应用并利用scale快速对容器进行扩容。&lt;/p&gt;&#xA;&lt;p&gt;由于docker compose启动的服务都在同一台宿主机上，对于一个宿主机上运行多个容器应用时，容器的运行情况如：CPU使用率、内存使用率、网络状态、磁盘空间等一系列随时间变化的时序数据信息，都是需要去了解，因此监控是必须的。&lt;/p&gt;&#xA;&lt;h2 id=&#34;容器监控方案选择&#34;&gt;容器监控方案选择&lt;/h2&gt;&#xA;&lt;p&gt;对于容器的监控方案可谓多种多样，本身自带命令docker stats命令，Scout,Data Dog,Sysdig Cloud,Sensu Monitoring Framework,CAdvisor等。&lt;/p&gt;&#xA;&lt;p&gt;通过docker stats命令可以很方便的看到当前宿主机上所有容器的CPU,内存以及网络流量等数据。但是docker stats命令的缺点就是统计的只是当前宿主机的所有容器，而获取的监控数据是实时的，没有地方存储,也没有报警功能。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;docker stats&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而Scout、Sysdig Cloud、Data Dog虽然都提供了较完善的服务，但是它们都是托管的服务而且都收费，Sensu Monitoring Framework集成度较高，也免费，但是部署过于复杂。综合考虑，我们选择了CAdvisor做容器监控工具。&lt;/p&gt;&#xA;&lt;p&gt;CAdvisor谷歌出品，优点是开源产品，监控指标齐全，部署方便，而且有官方的docker镜像。缺点是集成度不高，默认只在本地保存2分钟数据。不过可以加上InfluxDB存储数据，对接Grafana展示图表，比较便利地搭建好了容器监控系统，数据收集和图表展示效果良好，对系统性能也几乎没有什么影响。&lt;/p&gt;&#xA;&lt;h2 id=&#34;cadvisor&#34;&gt;CAdvisor&lt;/h2&gt;&#xA;&lt;p&gt;CAdvisor是一个容器资源监控工具,包括容器的内存,CPU,网络IO,磁盘IO等监控,同时提供了一个WEB页面用于查看容器的实时运行状态。CAdvisor默认存储2分钟的数据,而且只是针对单物理机。不过，CAdvisor提供了很多数据集成接口,支持InfluxDB,Redis,Kafka,Elasticsearch等集成,可以加上对应配置将监控数据发往这些数据库存储起来。&lt;/p&gt;&#xA;&lt;p&gt;CAdvisor功能主要有两点：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;展示Host和容器两个层次的监控数据。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;展示历史变化数据。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;influxdb&#34;&gt;InfluxDB&lt;/h2&gt;&#xA;&lt;p&gt;InfluxDB是用Go语言编写的一个开源分布式时序、事件和指标数据库,无需外部依赖。&lt;/p&gt;&#xA;&lt;p&gt;前面说到,CAdvisor默认只在本机保存最近2分钟的数据，为了持久化存储数据和统一收集展示监控数据，需要将数据存储到InfluxDB中。InfluxDB是一个时序数据库,专门用于存储时序相关数据，很适合存储CAdvisor的数据。而且，CAdvisor本身已经提供了InfluxDB的集成方法，丰启动容器时指定配置即可。&lt;/p&gt;&#xA;&lt;p&gt;InfluxDB主要功能:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;基于时间序列,支持与时间有关的相关函数(如最大、最小、求和等);&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;可度量性:你可以实时对大量数据进行计算;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;基于事件:它支持任意的事件数据;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;InfluxDB主要特点:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;无结构(无模式);&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;可以是任意数量的列;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;可拓展的;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;支持min,max,sum,count,mean,median等一系列函数,方便统计;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;原生的HTTP支持,内置HTTP API;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;强大的类SQL语法;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;自带管理界面,方便使用&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;granfana&#34;&gt;Granfana&lt;/h2&gt;&#xA;&lt;p&gt;Grafana是一个开源的数据监控分析可视化平台,支持多种数据源配置(支持的数据源包括InfluxDB,MySQL,Elasticsearch,OpenTSDB,Graphite等)和丰富的插件及模板功能,支持图表权限控制和报警。&lt;/p&gt;&#xA;&lt;p&gt;Grafan主要特性:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;灵活丰富的图形化选项&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;可以混合多种风格&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;支持白天和夜间模式&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;多个数据源&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;cadvisorinfluxdbgranfana&#34;&gt;CAdvisor+InfluxDB+Granfana&lt;/h2&gt;&#xA;&lt;p&gt;CAdvisor:负责收集容器的随时间变化的数据&lt;/p&gt;&#xA;&lt;p&gt;InfluxDB:负责存储时序数据&lt;/p&gt;&#xA;&lt;p&gt;Grafana:负责分析和展示时序数据&lt;/p&gt;&#xA;&lt;h2 id=&#34;安装部署&#34;&gt;安装部署&lt;/h2&gt;&#xA;&lt;h3 id=&#34;部署influxdb服务&#34;&gt;部署InfluxDB服务&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;docker run -d --name influxdb -p 8086:8086 &lt;span style=&#34;color:#ae81ff&#34;&gt;\&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;-v /data/influxdb:/var/lib/influxdb &lt;span style=&#34;color:#ae81ff&#34;&gt;\&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;--hostname&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;influxdb &lt;span style=&#34;color:#ae81ff&#34;&gt;\&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;influxdb&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;说明：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&amp;ndash;name:启运容器分配名字influxdb&lt;/p&gt;</description>
    </item>
    <item>
      <title>Docker进阶-资源管理Swarm&#43;Portainer</title>
      <link>http://localhost:1313/post/2019/docker-guide-swarm-portainer/</link>
      <pubDate>Fri, 07 Sep 2018 12:13:29 +0000</pubDate>
      <guid>http://localhost:1313/post/2019/docker-guide-swarm-portainer/</guid>
      <description>&lt;h2 id=&#34;docker-swarm资源管理&#34;&gt;Docker Swarm资源管理&lt;/h2&gt;&#xA;&lt;p&gt;Docker Swarm是Docker官方三剑客项目之一，提供Docker容器集群服务，是Docker官方对容器云生态进行支持的核心方案。&lt;/p&gt;&#xA;&lt;p&gt;使用它，用户可以将多个Docker主机封装为单个大型的虚拟Docker主机，快速打造一套容器云平台。&lt;/p&gt;&#xA;&lt;p&gt;注意：Docker1.12.0之后版本，Swarm模块已经内嵌入Docker引擎，成为Docker子命令docker swarm,绝大多用户已经开始使用Swarm模块，Docker引擎API已经删除Docker Swarm。&lt;/p&gt;&#xA;&lt;h3 id=&#34;基本概念&#34;&gt;基本概念&lt;/h3&gt;&#xA;&lt;p&gt;Swarm是使用SwarmKit构建的Docker引擎内置(原生)的集群管理和编排工具。使用Swarm集群之前需要了解以下几个概念。&lt;/p&gt;&#xA;&lt;h4 id=&#34;节点&#34;&gt;节点&lt;/h4&gt;&#xA;&lt;p&gt;运行Docker的主机可以主动初始化一个Swarm集群或者加入一个已存在的Swarm集群，这样运行Docker的主机就成为一个Swarm集群的节点(node)。&lt;/p&gt;&#xA;&lt;p&gt;节点分为管理(manager)节点和工作(worker)节点。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;管理节点用于Swarm集群的管理，docker swarm集合基本只能在管理节点执行。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;工作节点是任务执行节点，管理节点将服务(service)下发至工作节点执行。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;集群中管理节点与工作节点的关系&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://ueyao.github.io/image-hosting/blog/2019/8/docker-resource-manage-01.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;服务和任务&#34;&gt;服务和任务&lt;/h4&gt;&#xA;&lt;p&gt;任务(Task)是Swarm中的最小的调度单位，目前来说就是一个单一的容器。&lt;/p&gt;&#xA;&lt;p&gt;服务(Services)是指一组任务的集合，服务定义了任务的属性。&lt;/p&gt;&#xA;&lt;p&gt;服务有两种模式：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;replicated services 按照一定规则在各个工作节点上运行指定个数的任务。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;global services每个工作节点运行一个任务&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;两个模式通过docker service create的&amp;ndash;mode参数指定&lt;/p&gt;&#xA;&lt;p&gt;容器、任务、服务的关系&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://ueyao.github.io/image-hosting/blog/2019/8/docker-resource-manage-02.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;创建swarm集群&#34;&gt;创建Swarm集群&lt;/h3&gt;&#xA;&lt;p&gt;了解Swarm集群由管理节点和工作节点组成后，我们创建一个包含一个管理节点和两个工作节点的最小Swarm集群。&lt;/p&gt;&#xA;&lt;h4 id=&#34;初始化集群&#34;&gt;初始化集群&lt;/h4&gt;&#xA;&lt;p&gt;使用docker swarm init在本地初始化一个Swarm集群。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;docker swarm init --advertise-addr 192.168.1.1&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果你的Docker主机有多个网段，拥有多个IP，必须使用&amp;ndash;advertise-addr指定IP。执行docker swarm init命令的节点自动成为管理节点。&lt;/p&gt;&#xA;&lt;p&gt;注意：使用docker swarm init&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://ueyao.github.io/image-hosting/blog/2019/8/docker-resource-manage-03.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;增加工作节点&#34;&gt;增加工作节点&lt;/h4&gt;&#xA;&lt;p&gt;在另外两台服务器上执行上一步创建管理节点时候的输出的加入swarm集群的全集&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;docker swarm join &lt;span style=&#34;color:#ae81ff&#34;&gt;\&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;--token SWMTKN-1-3pu6hszjas19xyp7ghgosyx9k8atbfcr8p2is99znpy26u2lkl-1awxwuwd3z9j1z3puu7rcgdbx &lt;span style=&#34;color:#ae81ff&#34;&gt;\ &lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;192.168.1.1:2377&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;查看集群&#34;&gt;查看集群&lt;/h4&gt;&#xA;&lt;p&gt;在管理节点使用docker node ls查看集群。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;docker node ls&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://ueyao.github.io/image-hosting/blog/2019/8/docker-resource-manage-04.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;部署服务&#34;&gt;部署服务&lt;/h3&gt;&#xA;&lt;p&gt;使用docker service命令来管理Swarm集群中的服务，该命令只能在管理节点运行。&lt;/p&gt;&#xA;&lt;h4 id=&#34;新建服务&#34;&gt;新建服务&lt;/h4&gt;&#xA;&lt;p&gt;在创建好的Swarm集群中运行nginx服务&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
