<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on 薛尧笔记</title><link>https://xueyao.netlify.app/categories/java/</link><description>Recent content in Java on 薛尧笔记</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Sun, 25 Jul 2021 13:31:32 +0000</lastBuildDate><atom:link href="https://xueyao.netlify.app/categories/java/index.xml" rel="self" type="application/rss+xml"/><item><title>如何使用FTP中的模板文件和EasyPOI来导出Excle?</title><link>https://xueyao.netlify.app/post/2021/java-ftp-temple-easypoi-export-xls/</link><pubDate>Sun, 25 Jul 2021 13:31:32 +0000</pubDate><guid>https://xueyao.netlify.app/post/2021/java-ftp-temple-easypoi-export-xls/</guid><description>问题描述 因工作需要导出Excel文件，使用技术为EasyPOI,EasyPOI是一个非常好的导出文件工具，官网提供非常详细的使用文档，在项目中使用EasyPOI的模板导出功能，官方提供的示例代码中，模板的路径都是本地，我使用时也是把Excle模板文件放在本地，因为之前需要导出的地方，不是很多，模板文件放在本地也没有太大问题，但是由于现在需求变更，会有大量的模板需要导出，如果放在本地会造成项目容量变大。现在想把导出的模板保存在远程的FTP服务中，EasyPOI读取FTP的中模板文件生成Excle文件。
解决步骤 1、 查找解决方式 上网找了许多相关资料，官网上也没有找到解决方法，意外浏览了一篇文章，文章中提到了一句话，说EasyPOI读取模板文件，只支持读取本地模板文件，换句话来说，我只需要把FTP中的模板文件下载到本地指定路径，然后，就可以读取模板文件。
2、创建测试项目 创建一个SpringBoot项目，POM文件中引入需要的Jar包，如下
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;cn.hutool&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;hutool-all&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.7.5&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;cn.afterturn&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;easypoi-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.3.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;commons-net&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;commons-net&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.6&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 3、添加一些配置文件
ftp: host: 192.168.2.66 # IP port: 21 # 端口 username: root # 用户名 password: 123456 # 密码 mode: Passive # ftp模式 remotePath: /root/export/ # ftp模板路径 localPath: /Users/simonxue/Developer/Temp/ # 本地模板路径 template: employee: employee.xlsx #模板文件 3、 创建一个FTP下载方法，方法返回地址模板全路径名，如下所示
@Value(&amp;#34;${ftp.host}&amp;#34;) private String host; @Value(&amp;#34;${ftp.port}&amp;#34;) private Integer port; @Value(&amp;#34;${ftp.username}&amp;#34;) private String username; @Value(&amp;#34;${ftp.</description></item><item><title>JPA使用-实体类上常用注解</title><link>https://xueyao.netlify.app/post/2019/jpa-use-common-annotaion/</link><pubDate>Wed, 11 Dec 2019 12:45:59 +0000</pubDate><guid>https://xueyao.netlify.app/post/2019/jpa-use-common-annotaion/</guid><description> @SQLDelete 场景描述 JPA中提供了简单的CRUD操作，其中删除操作是物理删除，但是实际应用中，系统中的数据是一种资源，不能直接删除，应该做到逻辑删除，JPA中删除操作是不可取的。
场景示例 调用JPA的删除方法，如下代码所示：
@Test public void testJpaDelete() { //此处根据id删除角色信息 roleRepository.deleteById(1); } 执行上面的测试方法，数据表中主键为1的数据，已经被删除掉，看下JPA的执行SQL如下所示:
delete from role where id=? 此语句为JPA删除操作的默认执行语句。
解决方案 JPA的默认删除方法，并不可取，可以在Role实体上加上@SQLDelete注解，并写SQL语句，如下所示:
@SQLDelete(sql = &amp;#34;update role set is_deleted = 1 where id = ?&amp;#34;) 上面的注解代表着，只要执行JPA的删除操作，执行的SQL语句为我们自己定义的SQL语句。
测试一下 @Test public void testJpaDelete() { roleRepository.deleteById(2); } 结果打印的SQL执行语句，如下所示
update role set is_deleted = 1 where id = ? @DynamicInsert 场景描述 在JPA中添加/更新都是使用save()方法，一般情况下，创建数据表的时候，会给某些字段设置默认的值，避免在插入的时候手动赋值，如创建时间，是否删除等等。
save方法会把没有值的对象，默认赋空值，造成，原数据表的默认值失效。
场景示例 解决方案 @DynamicUpdate</description></item><item><title>代码优化-多态代替IF条件判断</title><link>https://xueyao.netlify.app/post/2019/code-optimize-if/</link><pubDate>Sun, 01 Dec 2019 12:45:00 +0000</pubDate><guid>https://xueyao.netlify.app/post/2019/code-optimize-if/</guid><description>场景描述 在开发的场景中，常常会遇到打折的业务需求，每个用户对应的等级，他们的打折情况也是不一样的。例如普通会员打9折，青铜会员打8.5折，黄金会员打8折等等。在一般开发中最简单的就是判断用户的等级，然后对订单作对应的打折处理。
场景示例 写了一个简单的小示例，如下所示：
//1 代表学生 2老师 3校长 int type = 1; if (1 == type) { System.out.println(&amp;#34;学生笑嘻嘻的说话&amp;#34;); } else if (2 == type) { System.out.println(&amp;#34;老师开心的说话&amp;#34;); } else { System.out.println(&amp;#34;校长严肃的说话&amp;#34;); } 上面的代码，是我们经常的做法，代码少的时候，看起来非常清晰，但是代码多起来或者有了更多的判断条件，那上面的代码会更加的混乱，如果每次有修改，都要改动这部分代码。
解决方法 可以把上面的代码改成多态方式，创建三个类，学生Student,老师Teacher,校长HeadMater，父类为Person，这三个类都实现父类的方法say，如下所示:
Person.class
package me.xueyao.service; /** * @author Simon.Xue * @date 2019-12-01 14:31 **/ public interface Person { void say(); } Student.class
package me.xueyao.service.impl; import me.xueyao.service.Person; import org.springframework.stereotype.Service; /** * @author Simon.Xue * @date 2019-12-01 14:34 **/ @Service public class Student implements Person { @Override public void say() { System.</description></item><item><title>Java多线程-线程通信</title><link>https://xueyao.netlify.app/post/2019/java-thread-communication/</link><pubDate>Tue, 03 Sep 2019 12:42:43 +0000</pubDate><guid>https://xueyao.netlify.app/post/2019/java-thread-communication/</guid><description>通信的方式 要想实现多个线程之间的协同，如：线程执行先后顺序、获取某个线程执行的结果等等。涉及到线程之间的相互通信，分为下面四类：
文件共享 网络共享 共享变量 JDK提供的线程协调API suspend/resume、wait/notify、park/unpark 文件共享 public class MainTest { public static void main(String[] args) { // 线程1 - 写入数据 new Thread(() -&amp;gt; { try { while (true) { Files.write(Paths.get(&amp;#34;test.log&amp;#34;), content = &amp;#34;当前时间&amp;#34; + String.valueOf(System.currentTimeMillis())); Thread.sleep(1000L); } } catch (Exception e) { e.printStackTrace(); } }).start(); // 线程2 - 读取数据 new Thread(() -&amp;gt; { try { while (true) { Thread.sleep(1000L); byte[] allBytes = Files.readAllBytes(Paths.get(&amp;#34;test.log&amp;#34;)); System.out.println(new String(allBytes)); } } catch (Exception e) { e.</description></item><item><title>Java多线程-线程中止</title><link>https://xueyao.netlify.app/post/2019/java-thread-stop/</link><pubDate>Mon, 26 Aug 2019 12:41:06 +0000</pubDate><guid>https://xueyao.netlify.app/post/2019/java-thread-stop/</guid><description>不正确的线程中止-Stop Stop:中止线程，并且清除监控器锁的信息，但是可能导致 线程安全问题，JDK不建议用。 Destroy: JDK未实现该方法。
/** * @author simon */ public class StopThread extends Thread { private int i = 0, j = 0; @Override public void run() { synchronized (this) { // 增加同步锁，确保线程安全 ++i; try { // 休眠10秒,模拟耗时操作 Thread.sleep(10000); } catch (InterruptedException e) { e.printStackTrace(); } ++j; } } /** * 打印i和j */ public void print() { System.out.println(&amp;#34;i=&amp;#34; + i + &amp;#34; j=&amp;#34; + j); } } /** * @author simon * 示例3 - 线程stop强制性中止，破坏线程安全的示例 */ public class Demo { public static void main(String[] args) throws InterruptedException { StopThread thread = new StopThread(); thread.</description></item><item><title>Java多线程-线程状态</title><link>https://xueyao.netlify.app/post/2019/java-thread-status/</link><pubDate>Sun, 25 Aug 2019 12:40:14 +0000</pubDate><guid>https://xueyao.netlify.app/post/2019/java-thread-status/</guid><description>线程状态 6个状态定义：java.lang.Thread.State
New: 尚未启动的线程的线程状态。 Runnable: 可运行线程的线程状态，等待CPU调度。 Blocked: 线程阻塞等待监视器锁定的线程状态。处于synchronized同步代码块或方法中被阻塞。 Waiting: 等待线程的线程状态。下列不带超时的方式：Object.wait、Thread.join、LockSupport.park Timed Waiting: 具有指定等待时间的等待线程的线程状态。下列超时的方式：Thread.sleep、Object.wait、Thread.join、LockSupport.parkNanos、LockSupport.parkUntil 常见线程状态切换 新建-&amp;gt;运行-&amp;gt;终止 Thread thread1 = new Thread(new Runnable() { @Override public void run() { System.out.println(&amp;#34;thread1当前状态：&amp;#34; + Thread.currentThread().getState().toString()); System.out.println(&amp;#34;thread1 执行了&amp;#34;); } }); System.out.println(&amp;#34;没调用start方法，thread1当前状态：&amp;#34; + thread1.getState().toString()); thread1.start(); Thread.sleep(2000L); // 等待thread1执行结束，再看状态 System.out.println(&amp;#34;等待两秒，再看thread1当前状态：&amp;#34; + thread1.getState().toString()); 新建-&amp;gt;运行-&amp;gt;等待-&amp;gt;运行-&amp;gt;终止 Thread thread2 = new Thread(new Runnable() { @Override public void run() { try {// 将线程2移动到等待状态，1500后自动唤醒 Thread.sleep(1500); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&amp;#34;thread2当前状态：&amp;#34; + Thread.</description></item><item><title>Java多线程-程序运行堆栈分析</title><link>https://xueyao.netlify.app/post/2019/java-thread-program-run-stack/</link><pubDate>Sun, 25 Aug 2019 12:39:19 +0000</pubDate><guid>https://xueyao.netlify.app/post/2019/java-thread-program-run-stack/</guid><description>class文件内容 class文件包含JAVA程序执行的字节码；数据严格按照格式紧凑排列在class文件中的二进制流，中间无任何分隔符；文件开头有一个0xcafebabe(16进制)特殊的一个标志。
JVM运行时数据区 线程独占：每个线程都会有它独立的空间，随线程生命周期而创建和销毁 线程共享：所有线程能访问这块内存数据，随虚拟机或者GC而创建和销毁
方法区 JVM用来存储加载的类信息、常量、静态变量、编译后的代码等数据。 虚拟机规范中这是一个逻辑区划。具体实现根据不同虚拟机来实现。 如：oracle的HotSpot在java7中方法区放在永久代，java8放在元数据空间，并且通过GC机制对这个区域进行管理
堆内存 堆内存还可以细分为：老年代、新生代(Eden、From Survivor、To Survivor) JVM启动时创建，存放对象的实例。垃圾回收器主要就是管理堆内存。 如果满了，就会出现OutOfMemoryError。
虚拟机栈 虚拟机栈，每个线程都在这个空间有一个私有的空间。 线程栈由多个栈帧(Stack Frame)组成。 一个线程会执行一个或多个方法，一个方法对应一个栈帧。 栈帧内容包含：局部变量表、操作数栈、动态链接、方法返回地址、附件信息等。 栈内存默认最大是1M，超出则抛出StackOverflowError
本地方法栈 和虚拟机栈功能类似，虚拟机栈是为虚拟机执行JAVA方法而准备的，本地方法栈是为虚拟机使用Native本地方法而准备。 虚拟机规范没有规定具体的实现，由不同的虚拟机厂商去实现。 HotSpot虚拟机中虚拟机栈和本地方法栈的实现方式一样的。同样，超出大小以后也会抛出StackOverflowError。
程序计数器 程序计数器(Program Counter Register)记录当前线程执行字节码的位置，存储的是字节码指令地址，如果执行Native方法，则计数器值为空。 每个线程都在这个空间有一个私有的空间，占用内存空间很少。 CPU同一时间，只会执行一条线程中的指令。JVM多线程会轮流切换并分配CPU执行时间的方式。为了线程切换后，需要通过程序计数器，来恢复正确的执行位置。</description></item><item><title>Java内存缓存-通过Google Guava创建缓存</title><link>https://xueyao.netlify.app/post/2019/java-cache-google-guava/</link><pubDate>Fri, 23 Aug 2019 12:37:51 +0000</pubDate><guid>https://xueyao.netlify.app/post/2019/java-cache-google-guava/</guid><description>谷歌Guava缓存 Guava介绍 Guava是Google guava中的一个内存缓存模块，用于将数据缓存到JVM内存中。实际项目开发中经常将一些公共或者常用的数据缓存起来方便快速访问。
Guava Cache是单个应用运行时的本地缓存。它不把数据存放到文件或外部服务器。如果不符合需求，可以选择Memcached、Redis等工具。
小案例 pom.xml添加guava依赖
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;project xmlns=&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xsi:schemaLocation=&amp;#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;#34;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;groupId&amp;gt;me.xueyao.cache&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;java-demo&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.cache&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;cache-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.1.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.google.guava&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;guava&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;27.0.1-jre&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;/project&amp;gt; GuavaCacheDemo.java 代码如下：
package me.xueyao.cache.java.guava; import com.google.common.cache.*; import me.xueyao.cache.java.pojo.User; import java.util.concurrent.ExecutionException; import java.util.concurrent.TimeUnit; /** * @author simon * https://github.com/google/guava */ public class GuavaCacheDemo { public static void main(String[] args) throws ExecutionException { //缓存接口这里是LoadingCache，LoadingCache在缓存项不存在时可以自动加载缓存 LoadingCache&amp;lt;String, User&amp;gt; userCache //CacheBuilder的构造函数是私有的，只能通过其静态方法newBuilder()来获得CacheBuilder的实例 = CacheBuilder.</description></item><item><title>Java内存缓存-通过Map定制简单缓存</title><link>https://xueyao.netlify.app/post/2019/java-cache-map/</link><pubDate>Thu, 22 Aug 2019 12:37:04 +0000</pubDate><guid>https://xueyao.netlify.app/post/2019/java-cache-map/</guid><description>缓存 在程序中，缓存是一个高速数据存储层，其中存储了数据子集，且通常是短暂性存储，这样日后再次请求此数据时，速度要比访问数据的主存储位置快。通过缓存，可以高效地重用之前检索或计算的数据。
为什么要用缓存 场景 在Java应用中，对于访问频率高，更新少的数据，通常的方案是将这类数据加入缓存中，相对从数据库中读取，读缓存效率会有很大提升。
在集群环境下，常用的分布式缓存有Redis、Memcached等。但在某些业务场景上，可能不需要去搭建一套复杂的分布式缓存系统，在单机环境下，通常是会希望使用内部的缓存(LocalCache)。
方案 基于JSR107规范自研
基于ConcurrentHashMap实现数据缓存
JSR107规范目标 为应用程序提供缓存Java对象的功能。
定义了一套通用的缓存概念和工具。
最小化开发人员使用缓存的学习成本。
最大化应用程序在使用不同缓存实现之间的可移植性。
支持进程内和分布式的缓存实现。
JSR107规范核心概念 Java Caching定义了5个核心接口，分别是CachingProvider, CacheManager, Cache, Entry 和 Expiry。
CachingProvider定义了创建、配置、获取、管理和控制多个CacheManager。一个应用可以在运行期访问多个CachingProvider。
CacheManager定义了创建、配置、获取、管理和控制多个唯一命名的Cache，这些Cache存在于- CacheManager的上下文中。一个CacheManager仅被一个CachingProvider所拥有。
Cache是一个类似Map的数据结构并临时存储以Key为索引的值。一个Cache仅被一个CacheManager所拥有。
Entry是一个存储在Cache中的key-value对。
每一个存储在Cache中的条目有一个定义的有效期，即Expiry Duration。
一旦超过这个时间，条目为过期的状态。一旦过期，条目将不可访问、更新和删除。缓存有效期可以通过ExpiryPolicy设置。
小例子 使用Map来实现一个简单的缓存功能
MapCacheDemo.java
package me.xueyao.cache.java; import java.lang.ref.SoftReference; import java.util.Optional; import java.util.concurrent.ConcurrentHashMap; /** * @author simon * 用map实现一个简单的缓存功能 */ public class MapCacheDemo { /** * 使用 ConcurrentHashMap，线程安全的要求。 * 我使用SoftReference &amp;lt;Object&amp;gt; 作为映射值，因为软引用可以保证在抛出OutOfMemory之前，如果缺少内存，将删除引用的对象。 * 在构造函数中，我创建了一个守护程序线程，每5秒扫描一次并清理过期的对象。 */ private static final int CLEAN_UP_PERIOD_IN_SEC = 5; private final ConcurrentHashMap&amp;lt;String, SoftReference&amp;lt;CacheObject&amp;gt;&amp;gt; cache = new ConcurrentHashMap&amp;lt;&amp;gt;(); public MapCacheDemo() { Thread cleanerThread = new Thread(() -&amp;gt; { while (!</description></item><item><title>ElasticSearch从入门到放弃(一)-安装&amp;运行</title><link>https://xueyao.netlify.app/post/2018/java-elastic-search-install-run/</link><pubDate>Thu, 18 Oct 2018 12:19:00 +0000</pubDate><guid>https://xueyao.netlify.app/post/2018/java-elastic-search-install-run/</guid><description>这几天看到新闻，说ElasticSearch上市了，真的没有想到这个非常流行的开源项目竟然上市了，这个公司的程序员都走上了财务自由的道路。 以前用过ElasticSearch全文搜索引擎，但是时间长也忘记了差不多了，以前而且还是用的老版本，不知道新版本如何使用，废话不多说了，开始：
本地环境及版本 Java1.8 ElasticSearch6.4.2 kibana6.4.2 步骤 下载ElasticSearch 选择自己操作系统所对应的版本 解压后的目录 进入bin目录下，运行elasticsearch命令 看到下图，就说明elasticsearch启动成功，如果你的电脑是Linux，会提示不允许使用root运行，请使用elasticsearch用户启动程序 浏览器查看http://127.0.0.1:9200,出现下图则说明ElasticSearch启动成功 现在ElasticSearch启动好了，再安装一个图形化操作插件Kibana,原本准备安装Sense，结果安装失败，后来知道，6.4.2版本里已经不支持安装Sense，现在Kibana集成了Sense功能，只需要安装Kibana,下载地址如下 解压Kibana文件到ElasticSearch目录下(个人习惯) 运行Kibana项目(/bin/kibana)，看到下图，红色警告部分，因为ElasticSearch服务没有启动，所以kibana项目报告，心跳检测有没有ElasticSearch服务 当启动ElasticSearch服务，kibana程序检测到有活着的elasticSearch服务，立即注册上 浏览器查看http://127.0.0.1:5601,出现下图则说明Kibana启动成功 总结 ElasticSearch和Kibana安装和运行是非常容易的，但是还有许多细节需要注意，操作系统和ElasticSearch版本都要弄清楚。</description></item><item><title>IntelliJ IDEA技巧一之隐藏.idea目录</title><link>https://xueyao.netlify.app/post/2018/java-intelllij-hidden-idea-dir/</link><pubDate>Thu, 11 Oct 2018 12:17:11 +0000</pubDate><guid>https://xueyao.netlify.app/post/2018/java-intelllij-hidden-idea-dir/</guid><description> 问题场景 通过IntelliJ IDEA软件创建Java Web项目时，项目目录中总会生成.idea配置目录并在软件界面里显示，影响项目美感，如何在软件界面中隐藏.idea目录呢？
解决方法 打开IDEA软件的设置(Mac是Preferences,Windows是Settings) 点击Editor-&amp;gt;File Types Ignore file and folders中添加.idea;(分号为间隔，以后隐藏文件都在这个地方配置)</description></item><item><title>CPU缓存和内存屏障</title><link>https://xueyao.netlify.app/post/2019/java-cup-cache-memory-barrier/</link><pubDate>Fri, 07 Sep 2018 12:13:29 +0000</pubDate><guid>https://xueyao.netlify.app/post/2019/java-cup-cache-memory-barrier/</guid><description>CPU性能优化手段-缓存 为了提高程序运行的性能，现代CPU在很多方面对程序进行了优化。
例如：CPU高速缓存。尽可能地避免处理器访问主内存的时间开销，处理器大多会利用缓存(cache)以提高性能。
多级缓存 L1 Cache(一级缓存)是CPU第一层高速缓存，分为数据缓存和指令缓存。一般服务器CPU的L1缓存的容量通常在32-4096KB。
L2由于L1级高速缓存容量的限制，为了再次提高CPU的运算速度，在CPU外部放置-高速存储器，即二级缓存。
L3现在的都是内置的。而它的实际作用即是，L3缓存的应用可以进一步降低内存延迟，同时提升大数据量计算时处理器的性能。具有较大L3缓存的处理器提供更有效的文件系统缓存行为及较短消息和处理器队列长度。一般是多核共享一个L3缓存！
CPU在读取数据时，先在L1中寻找，再从L2寻找，再从L3寻找，然后是内存，再后是外存储器。
缓存同步协议 多CPU读取同样的数据进行缓存，进行不同运算之后，最终写入主内存以哪个CPU为准？
在这种高速缓存回写的场景下，有一个缓存一致性协议多数CPU厂商对它进行了实现。
MESI协议，它规定每条缓存有个状态位，同时定义了下面四个状态：
修改态(Modified)-此cache行已被修改过(脏行),内容已不同于主存，为此cache专有；
专有态(Exclusive)-此cache行内容同于主存，但不出现于其它cache中；
共享态(Shared)-此cache行内容同于主存，但也出现于其它cache中；
无效态(Invalid)-此cache行内容无效(空行)。
多处理器，单个CPU对缓存中数据进行了改动，需要通知给其它CPU。也就是意味着，CPU处理要控制自己的读写操作，还要监听其他CPU发出的通知，从而保证最终一致。
CPU性能优化手段-运行时指令重排 指令重排的场景：当CPU写缓存时发现缓存区块正被其他CPU占用，为了提高CPU处理性能，可能将后面的读缓存命令优先执行。
并非随便重排，需要遵守s-if-serial语义
as-if-serial语义的意思指：不管怎么重排序(编译器和处理器为了提高并行度)，(单线程）程序的执行结果不能被改变。编译器，runtime和处理器都必须遵守as-if-serial语义。也就是说：编译器和处理器不会对存在数据依赖关系的操作做重排序。
两个问题 1、CPU高速缓存下有一个问题：
缓存中数据与主内存的数据并不是实时同步的，各CPU(或CPU核心)间缓存的数据也不是实时同步。
在同一个时间点，各CPU所看到同一内存地址的数据的值可能是不一致的。
2、CPU执行指令重排序优化下有一个问题：
虽然遵守了as-if-serial语义，单仅在单CPU自己执行的情况下能保证结果正确。多核多线程中，指令逻辑无法分辨因果关联，可能出现乱序执行，导致程序运行结果错误。
内存屏障 处理器提供了两个内存屏障指令(Memory Barrier)用于解决上述两个问题：
写内存屏障(Store Memory Barrier):在指令后插入Store Barrier,能让写入缓存中的最新数据更新写入主内存，让其他线程可见。强制写入主内存，这种显示调用，CPU就不会因为性能考虑而去对指令重排。
读内存屏障(Load Memory Barrier):在指令前插入Load Barrier,可以让高速缓存中的数据失效，强制从主内存加载数据。强制读取主内存内容，让CPU缓存与主内存保持一致，避免了缓存导致的一致性问题。</description></item><item><title>Ehcache缓存简单使用</title><link>https://xueyao.netlify.app/post/2017/java-cache-ehcache-use/</link><pubDate>Sat, 25 Nov 2017 12:10:42 +0000</pubDate><guid>https://xueyao.netlify.app/post/2017/java-cache-ehcache-use/</guid><description>SPRING整合EHCACHE 1.引入坐标 pom.xml
&amp;lt;!-- ehcache的缓存框架 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;net.sf.ehcache&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;ehcache-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.6.10&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- spring整合第三方框架的 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-context-support&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 2.配置Ehcache ehcache.xml
&amp;lt;ehcache xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xsi:noNamespaceSchemaLocation=&amp;#34;../config/ehcache.xsd&amp;#34;&amp;gt; &amp;lt;!-- 硬盘上缓存的临时目录 --&amp;gt; &amp;lt;diskStore path=&amp;#34;java.io.tmpdir&amp;#34;/&amp;gt; &amp;lt;!-- maxElementsInMemory:内存中最大存放的元素的个数 eternal：是否永生，默认是false timeToIdleSeconds：发呆闲置的时间，超过该时间，被清除，单位秒 timeToLiveSeconds：存活的事件，超过该时间被清除 maxElementsOnDisk：如果内存满了，溢出到硬盘上的临时目录中的存放的元素的个数 diskExpiryThreadIntervalSeconds：轮询时间，巡视组 memoryStoreEvictionPolicy：内存对象的清理策略，如果满了，怎么办? 策略有三个：LRU、LFU、FIFO LRU:最少使用被清理，次数 LFU：时间，闲置最长的时间 FIFO：管道策略，先进先出 --&amp;gt; &amp;lt;defaultCache maxElementsInMemory=&amp;#34;10000&amp;#34; eternal=&amp;#34;false&amp;#34; timeToIdleSeconds=&amp;#34;120&amp;#34; timeToLiveSeconds=&amp;#34;120&amp;#34; maxElementsOnDisk=&amp;#34;10000000&amp;#34; diskExpiryThreadIntervalSeconds=&amp;#34;120&amp;#34; memoryStoreEvictionPolicy=&amp;#34;LRU&amp;#34;&amp;gt; &amp;lt;persistence strategy=&amp;#34;localTempSwap&amp;#34;/&amp;gt; &amp;lt;/defaultCache&amp;gt; &amp;lt;!-- Spring整合的菜单缓存 --&amp;gt; &amp;lt;cache name=&amp;#34;project_menu_cache&amp;#34; maxElementsInMemory=&amp;#34;10000&amp;#34; eternal=&amp;#34;false&amp;#34; timeToIdleSeconds=&amp;#34;120&amp;#34; timeToLiveSeconds=&amp;#34;120&amp;#34; maxElementsOnDisk=&amp;#34;10000000&amp;#34; diskExpiryThreadIntervalSeconds=&amp;#34;120&amp;#34; memoryStoreEvictionPolicy=&amp;#34;LRU&amp;#34;&amp;gt; &amp;lt;persistence strategy=&amp;#34;localTempSwap&amp;#34;/&amp;gt; &amp;lt;/cache&amp;gt; &amp;lt;/ehcache&amp;gt; 3.</description></item><item><title>Quartz作业调度的入门使用</title><link>https://xueyao.netlify.app/post/2017/java-quartz-guide/</link><pubDate>Tue, 14 Nov 2017 12:09:41 +0000</pubDate><guid>https://xueyao.netlify.app/post/2017/java-quartz-guide/</guid><description>概念 1.Job
表示一个工作，要执行的具体的内容。此接口中只有一个方法
2.JobDetail
JobDetail表示一个具体的可执行的调度程序，Job是这个可执行调度程序所要执行的内容
3.Trigger
Trigger代表一个调度参数的配置
4.Scheduler
Scheduler代表一个调度容器，一个调度容器中可以注册多个JobDetail和Trigger.
说明：
编写job实现业务，要做什么具体事情 使用JobDetail包装job，是任务对象，可以被调度 使用Trigger定制什么时候去调用某任务对象 使用Scheduler结合任务对象和触发器对象 第一个任务 1.引入依赖坐标
pom.xml
&amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.quartz-scheduler&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;quartz&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.2.3&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.quartz-scheduler&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;quartz-jobs&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.2.3&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- slf4j log4j --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;slf4j-log4j12&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.7.7&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; 2.简单测试类
QuartzTest.java
package me.xueyao.quartz.test; import org.junit.Test; import org.quartz.Scheduler; import org.quartz.impl.StdSchedulerFactory; /** * @author XueYao * @date 2017-11-26 */ public class QuartzTest { //quartz容器启动和关闭 @Test public void testFirst() throws Exception { //Scheduler scheduler = StdSchedulerFactory.</description></item><item><title>Javamail简单使用案例</title><link>https://xueyao.netlify.app/post/2017/java-email-simple-use-example/</link><pubDate>Wed, 13 Sep 2017 12:02:47 +0000</pubDate><guid>https://xueyao.netlify.app/post/2017/java-email-simple-use-example/</guid><description>邮件开发环境搭建 邮件服务器 易邮邮件服务器 配置如下 邮件客户端 Foxmail 配置如下 使用Javamail发送邮件 1、下载
javamail-samples.zip javax.mail.jar 官网地址http://www.oracle.com/technetwork/java/javamail/index.html
2、使用javamail
发送到本地的邮件中
package org.xueyao.email; import java.util.Date; import java.util.Properties; import javax.mail.Message; import javax.mail.Session; import javax.mail.Transport; import javax.mail.internet.InternetAddress; import javax.mail.internet.MimeMessage; public class MailUtils { /** * 发送邮件 * @param to 接收邮件的地址 * @param subject 邮件主题 * @param msgText 邮件内容 */ public static void send(String to, String subject, String msgText) { //发邮件的地址 String from = &amp;#34;admin@flowstone.com&amp;#34;; //邮件发送服务器地址 String host = &amp;#34;localhost&amp;#34;; //是否开启debug模式 boolean debug = true; // 设置发送邮件的配置信息 Properties props = new Properties(); props.</description></item><item><title>关于equals()方法两边变量如何放置</title><link>https://xueyao.netlify.app/post/2017/java-how-use-equals/</link><pubDate>Fri, 07 Jul 2017 11:29:08 +0000</pubDate><guid>https://xueyao.netlify.app/post/2017/java-how-use-equals/</guid><description> 两个变量放置位置 如果是两个都是变量，可以放在equals任意一边，没有区别
常量、变量放置位置 如果有一个是常量，equals()方法在使用时，建议equals()方法前面放常量。因为equals()是Object类中定义的，任何对象都可以调用equals()方法，但是，如果对象的值是null的话，会引起空指针异常。
如果变量放在前面也就相当调用变量的equals()方法，变量为空时，就会报空指针异常。所以把常量放在equals()方法前面，是非常好的习惯。
再者，如果变量放在equals()方法的括号内，变量为空时，equals()方法和null做比较，不会出现异常。
如下：
//constant为常量，variable为变量constant.equals(variable); //建议这样使用variable.equals(constant); //不建议使用，当变量为空时，会出现空指针异常</description></item><item><title>Java Random入门</title><link>https://xueyao.netlify.app/post/2017/java-random-guide/</link><pubDate>Sun, 02 Jul 2017 11:28:02 +0000</pubDate><guid>https://xueyao.netlify.app/post/2017/java-random-guide/</guid><description>什么是Random？ 当用户要产生一个随机数，java本身提供了丰富的Random类。用户可以根据需求创建Random对象，根据Random类下的方法创建特殊的随机数。
如何创建Random?
首先用户要创建一个Random对象
Random random = new Random(); 不过在使用对象之前，要导入对应的包
import java.util.Random; 当用户要创建一个整型的随机数，范围在0-100之间
/* 创建随机数时，如nextInt(m),里面的范围有一定的规律，如果用户要创建一个m-n(包括m,n)的随机数时， 公式：nextInt(n-m+1)+m;如果用户要创建一个m-n(不包括m,n)的随机数时，公式：nextInt(n-m); */ int num = random.nextInt(101); 用户可以创建各种类型的随机数，只需要使用对应的方法，即可生成。</description></item></channel></rss>