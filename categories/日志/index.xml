<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>日志 on 薛尧笔记</title><link>http://blog.xueyao.tech/categories/%E6%97%A5%E5%BF%97/</link><description>Recent content in 日志 on 薛尧笔记</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Mon, 17 Feb 2025 19:18:42 +0000</lastBuildDate><atom:link href="http://blog.xueyao.tech/categories/%E6%97%A5%E5%BF%97/index.xml" rel="self" type="application/rss+xml"/><item><title>Oracle 数据库常见操作技巧</title><link>http://blog.xueyao.tech/post/2025/20250217-03/</link><pubDate>Mon, 17 Feb 2025 19:18:42 +0000</pubDate><guid>http://blog.xueyao.tech/post/2025/20250217-03/</guid><description>在企业级应用开发中，Oracle 数据库作为一款功能强大且广泛使用的关系型数据库管理系统，掌握其常见操作技巧对于提升数据处理效率和应用性能至关重要。本文将围绕一系列 Oracle 数据库操作，结合具体代码进行详细解析。
一、数据插入与更新操作 （一）批量插入操作 在实际业务中，当需要向数据库中批量插入数据时，我们可以使用以下 SQL 语句结合 MyBatis 的&amp;lt;foreach&amp;gt;​标签来实现：
INSERT ALL &amp;lt;foreach collection=&amp;#34;list&amp;#34; item=&amp;#34;item&amp;#34; index=&amp;#34;index&amp;#34;&amp;gt; INTO TEST_QUESTION &amp;lt;trim prefix=&amp;#34;(&amp;#34; suffix=&amp;#34;)&amp;#34;&amp;gt; &amp;lt;include refid=&amp;#34;Base_List&amp;#34;&amp;gt;&amp;lt;/include&amp;gt; &amp;lt;/trim&amp;gt; &amp;lt;trim prefix=&amp;#34;VALUES (&amp;#34; suffix=&amp;#34;)&amp;#34;&amp;gt; #{item.qId,jdbcType=VARCHAR}, #{item.infoId,jdbcType=VARCHAR}, #{item.questionContent,jdbcType=VARCHAR}, #{item.answerContent,jdbcType=VARCHAR}, #{item.answerContentEn,jdbcType=VARCHAR}, #{item.questionContentEn,jdbcType=VARCHAR}, #{item.creator,jdbcType=VARCHAR}, #{item.createTime,jdbcType=TIMESTAMP}, #{item.updater,jdbcType=VARCHAR}, #{item.updateTime,jdbcType=TIMESTAMP}, #{item.optionCategory,jdbcType=VARCHAR} &amp;lt;/trim&amp;gt; &amp;lt;/foreach&amp;gt; SELECT 1 FROM DUAL 上述代码中，通过&amp;lt;foreach&amp;gt;​循环遍历集合list​，将每个元素item​的数据插入到TEST_QUESTION​表中。Base_List​中定义了表的列名，通过&amp;lt;include&amp;gt;​标签引入，实现了灵活的列定义复用。
（二）批量更新操作 批量更新数据时，使用 MyBatis 的&amp;lt;update&amp;gt;​标签结合&amp;lt;foreach&amp;gt;​标签：
&amp;lt;update id=&amp;#34;updateBatch&amp;#34; parameterType=&amp;#34;java.util.List&amp;#34;&amp;gt; &amp;lt;foreach collection=&amp;#34;list&amp;#34; item=&amp;#34;item&amp;#34; index=&amp;#34;index&amp;#34; open=&amp;#34;begin&amp;#34; close=&amp;#34;;end;&amp;#34; separator=&amp;#34;;&amp;#34;&amp;gt; update TEST_TABLE &amp;lt;set&amp;gt; tableName = #{item.tableName} &amp;lt;/set&amp;gt; where tableId = item.</description></item><item><title>MyBatis Plus中XML复杂映射，一对多，多中一对一"</title><link>http://blog.xueyao.tech/post/2025/20250217-02/</link><pubDate>Mon, 17 Feb 2025 18:18:42 +0000</pubDate><guid>http://blog.xueyao.tech/post/2025/20250217-02/</guid><description>现实生活中的例子 我们先不看代码，想象一下，你在管理一个学校的信息系统。学校里有老师，每个老师可以教多个班级，这就是典型的一对多关系。而每个班级里又有一个班主任，这就是多中嵌套一对一的关系。在数据库里，这些信息可能存放在不同的表中，而我们要用 Java 代码把它们整合起来。
MyBatis Plus 的resultMap来帮忙 resultMap就是 MyBatis 里用来建立数据库表和 Java 对象之间关系的工具。下面我们通过一段结合学校场景的具体代码，来看看它是怎么工作的，以及是否存在潜在问题。
代码示例 &amp;lt;resultMap id=&amp;#34;teacherSchoolMap&amp;#34; type=&amp;#34;com.school.vo.TeacherVO&amp;#34;&amp;gt; &amp;lt;result column=&amp;#34;TEACHER_ID&amp;#34; jdbcType=&amp;#34;VARCHAR&amp;#34; property=&amp;#34;id&amp;#34;/&amp;gt; &amp;lt;result column=&amp;#34;TEACHER_NAME&amp;#34; jdbcType=&amp;#34;VARCHAR&amp;#34; property=&amp;#34;name&amp;#34;/&amp;gt; &amp;lt;result column=&amp;#34;HIRE_DATE&amp;#34; jdbcType=&amp;#34;TIMESTAMP&amp;#34; property=&amp;#34;hireDate&amp;#34;/&amp;gt; &amp;lt;collection property=&amp;#34;teachingClasses&amp;#34; ofType=&amp;#34;com.school.vo.ClassVO&amp;#34;&amp;gt; &amp;lt;id column=&amp;#34;CLASS_ID&amp;#34; jdbcType=&amp;#34;VARCHAR&amp;#34; property=&amp;#34;id&amp;#34; /&amp;gt; &amp;lt;result column=&amp;#34;CLASS_NAME&amp;#34; jdbcType=&amp;#34;VARCHAR&amp;#34; property=&amp;#34;className&amp;#34; /&amp;gt; &amp;lt;result column=&amp;#34;CREATION_TIME&amp;#34; jdbcType=&amp;#34;TIMESTAMP&amp;#34; property=&amp;#34;creationTime&amp;#34; /&amp;gt; &amp;lt;association property=&amp;#34;classTeacher&amp;#34; javaType=&amp;#34;com.school.vo.TeacherVO&amp;#34; resultMap=&amp;#34;classTeacherMap&amp;#34;&amp;gt; &amp;lt;/association&amp;gt; &amp;lt;/collection&amp;gt; &amp;lt;/resultMap&amp;gt; &amp;lt;resultMap id=&amp;#34;classTeacherMap&amp;#34; type=&amp;#34;com.school.vo.TeacherVO&amp;#34;&amp;gt; &amp;lt;id column=&amp;#34;CLASS_TEACHER_ID&amp;#34; jdbcType=&amp;#34;VARCHAR&amp;#34; property=&amp;#34;id&amp;#34; /&amp;gt; &amp;lt;result column=&amp;#34;CLASS_TEACHER_NAME&amp;#34; jdbcType=&amp;#34;VARCHAR&amp;#34; property=&amp;#34;name&amp;#34; /&amp;gt; &amp;lt;result column=&amp;#34;CONTACT_NUMBER&amp;#34; jdbcType=&amp;#34;VARCHAR&amp;#34; property=&amp;#34;contactNumber&amp;#34; /&amp;gt; &amp;lt;/resultMap&amp;gt; 一对多关系的映射 在上面的代码里，标签就是用来处理一对多关系的。teacherSchoolMap对应的 Java 对象代表一位老师，而teachingClasses是这位老师所教的多个班级，一个老师可以教多个班级，这就是一对多关系。通过property指定 Java 对象里的集合属性名，ofType指定集合里每个元素的类型，MyBatis 就能把数据库里相关的数据，正确地放进这个集合里。</description></item><item><title>手动分页代码解析</title><link>http://blog.xueyao.tech/post/2025/20250217-01/</link><pubDate>Mon, 17 Feb 2025 17:18:42 +0000</pubDate><guid>http://blog.xueyao.tech/post/2025/20250217-01/</guid><description>注意：一般情况下请使用分页插件，特殊情况才能使用手动分页!!!!
在软件开发中，分页功能是非常常见的，它可以将大量数据按一定规则分割成多个页面展示，提高用户体验和系统性能。本文将详细解析一段实现手动分页功能的代码，并探讨其是否存在问题。
代码展示 // 数据总条数 int size = resps.size(); // 分割数据(手动分页) List&amp;lt;QueryDeviceNameResp&amp;gt; queryDeviceNameResps = resps.subList((pageNo - 1) * pageSize &amp;gt; size? size : (pageNo - 1) * pageSize, pageNo * pageSize &amp;gt; size? size : pageNo * pageSize); // 记录数据 page.setRecords(queryDeviceNameResps); // 总条数 page.setTotal(size); // 总页数 page.setPages(size / pageSize + 1); 代码解析 获取数据总条数： int size = resps.size(); 这行代码通过resps.size()获取数据集合resps的总元素个数，即数据总条数。size变量后续用于计算分页相关的参数。
分割数据实现手动分页： List&amp;lt;QueryDeviceNameResp&amp;gt; queryDeviceNameResps = resps.subList((pageNo - 1) * pageSize &amp;gt; size? size : (pageNo - 1) * pageSize, pageNo * pageSize &amp;gt; size?</description></item><item><title>Java 集合数据处理技巧：使用 Stream API 实现多种操作</title><link>http://blog.xueyao.tech/post/2025/20250216-02/</link><pubDate>Sun, 16 Feb 2025 19:18:42 +0000</pubDate><guid>http://blog.xueyao.tech/post/2025/20250216-02/</guid><description>在 Java 开发中，对集合数据进行处理是非常常见的需求，例如去重、排序、分组、求和等。Java 8 引入的 Stream API 为我们提供了一种简洁、高效的方式来处理集合数据。本文将详细介绍如何使用 Stream API 实现多种集合数据处理操作，并给出相应的代码示例。
1. List 根据某个属性去重 在处理 List​ 数据时，有时需要根据对象的某个属性进行去重。可以使用 TreeSet​ 和 Stream​ 来实现这一功能。以下是示例代码：
import java.util.ArrayList; import java.util.Comparator; import java.util.List; import java.util.TreeSet; import java.util.stream.Collectors; // 定义 SKU 类 class SKU { private String gid; public SKU(String gid) { this.gid = gid; } public String getGid() { return gid; } } public class ListDistinctByProperty { public static void main(String[] args) { List&amp;lt;SKU&amp;gt; skuList = new ArrayList&amp;lt;&amp;gt;(); skuList.</description></item><item><title>从手动到自动：代码多平台同步的最终秘籍</title><link>http://blog.xueyao.tech/post/2025/20250216-01/</link><pubDate>Sun, 16 Feb 2025 18:18:42 +0000</pubDate><guid>http://blog.xueyao.tech/post/2025/20250216-01/</guid><description>一、背景与需求 在日常开发中，我习惯将代码存储在 Github 上。然而，由于网络访问的限制，时常会遇到无法访问的情况。为了确保其他用户能够顺利访问我的代码，我期望在向 Github 提交代码时，能够同步将代码推送到多个代码托管平台，如 Gitee、Gitlab、Bitbucket 等。
二、初始方案：本地配置多仓库地址 起初，我通过在本地配置多个仓库地址来实现这一需求，具体命令如下：
git remote add github 仓库地址 git remote add gitee 仓库地址 但是，每次提交代码时，都需要手动依次将代码推送到各个对应的仓库，操作较为繁琐：
git push github main git push gitee main 三、使用 Github Action 实现自动化同步 后来，Github Action 的出现提供了自动化操作的解决方案。我开始使用它来实现多平台同步。不过，在使用多个平台同步功能时，需要事先向每个同步平台申请访问 Token。这些 Token 通常只能显示一次，当开启新的项目时，我常常忘记之前的 Token，导致难以再次配置。
之前使用的同步代码如下：
# Sample workflow for building and deploying a Jekyll site to GitHub Pages name: Push Other Pages on: # Runs on pushes targeting the default branch push: branches: [&amp;#34;main&amp;#34;] # Allows you to run this workflow manually from the Actions tab workflow_dispatch: jobs: # Build job build: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 with: ref: gh-pages fetch-depth: 0 # &amp;lt;-- clone with complete history - name: Sync Repo to Bitbucket uses: heussd/mirror-to-bitbucket-github-action@v2 with: username: flowstone spacename: flowstone repository: flowstone.</description></item><item><title>关于FSGithubPNG生成外链时描述出现路径问题</title><link>http://blog.xueyao.tech/post/2025/20250211-02/</link><pubDate>Tue, 11 Feb 2025 19:18:42 +0000</pubDate><guid>http://blog.xueyao.tech/post/2025/20250211-02/</guid><description>之前在FSGithubPNG上添加一个新的功能，就是上传图片后生成的外链可以是Markdown格式的图片链接，
如下：
![美丽的风景](https://example.com/path/to/your/image.jpg) 图片描述在不同系统下的差异 在 macOS 系统中，图片外链的图片描述为图片名称；而在 Windows 系统中，图片描述为带全路径的名称，如下所示：
![C:\Users\ADMINI~1\AppData\Local\Temp\tmp_rqboyon.png](https://cdn.jsdelivr.net/gh/ueYao/image-hosting@main/blog/2025/02/20250212202236212250.png) ​​
我希望上述的图片外链中描述只应该有图片的名称，原始代码如下：
# 获取当前日期 now = datetime.datetime.now() year = str(now.year) month = str(now.month).zfill(2) # 生成唯一文件名 original_name = self.file_path.split(&amp;#34;/&amp;#34;)[-1] extension = original_name.split(&amp;#34;.&amp;#34;)[-1] unique_name = f&amp;#34;{CommonUtil.get_current_time_str()}.{extension}&amp;#34; base_folder = self.github_root_folder target_path =f&amp;#34;{base_folder}/{year}/{month}/{unique_name}&amp;#34; if base_folder else f&amp;#34;{year}/{month}/{unique_name}&amp;#34; 之前是取original_name为图片的描述，但是现在已经用unique_name代替原来的文件名，
if response.status_code == 201: download_url = response.json().get(&amp;#34;content&amp;#34;).get(&amp;#34;download_url&amp;#34;) if self.github_cdn_checked: image_url = download_url.replace(&amp;#34;https://raw.githubusercontent.com/&amp;#34;, &amp;#34;https://cdn.jsdelivr.net/gh/&amp;#34;).replace(f&amp;#34;{self.github_repo}/&amp;#34;, f&amp;#34;{self.github_repo}@&amp;#34;) logger.info(f&amp;#34;CDN 加速jsDelivr：{image_url}&amp;#34;) else: image_url = download_url logger.info(f&amp;#34;上传成功！图片外链：{image_url}&amp;#34;) if self.github_markdown_checked: # 原始代码 #image_url = f&amp;#34;!</description></item><item><title>PySide6 项目开发全攻略：打造你的文件重命名神器</title><link>http://blog.xueyao.tech/post/2025/pyside-guide-rename/</link><pubDate>Sat, 08 Feb 2025 13:18:42 +0000</pubDate><guid>http://blog.xueyao.tech/post/2025/pyside-guide-rename/</guid><description>家人们，今天来给大家唠唠如何用 PySide6 打造一个超实用的文件重命名工具。这篇文章适合想搞点 GUI 开发的 Python 小白，也能帮有经验的大佬查漏补缺。话不多说，咱们开整！
一、开发环境搭建：魔法工具大集合 1.1 开发工具 开发前，咱们得先把 “魔法工具” 准备好：
PyCharm 2023.1：这可是 Python 开发的神器，智能代码补全就像你的专属小秘书，敲代码的时候自动提示，效率飞起！还集成了 Qt Designer，可视化界面设计，拖拖拽拽就搞定，简直不要太爽！ Python 3.10：建议大家用虚拟环境，venv 或者 conda 都行。就好比给你的项目穿上一层 “隔离衣”，每个项目都有自己独立的 Python 环境，互不干扰，再也不用担心包冲突的问题啦！ PySide6 6.5.0：Qt 官方钦点的 Python 绑定库，有了它，就能轻松调用 Qt 的各种强大功能，搭建出酷炫的 GUI 界面。 1.2 项目结构：文件的秘密基地 项目结构就像一个有序的小基地，每个文件都有自己的 “小窝”：
FsPySide6Project/ ├──.gitignore # 版本控制的“小卫士”，忽略那些不需要的文件 ├── batch_file_renamer.py # 文件重命名的“大脑”，核心功能都在这儿 ├── main.py # 程序入口，就像房子的大门，从这儿开始你的旅程 ├── main_window.py # 主窗口界面，是你的“门面担当” └── requirements.txt # 依赖清单，记录着项目需要的各种“小帮手” 来看看这些文件都在干啥：
.gitignore：默默守护着项目，把__pycache__/、.idea/ 这些开发环境文件拒之门外，让你的代码仓库干干净净。 requirements.txt：里面写着PySide6&amp;gt;=6.5.0，这是项目的 “粮草清单”，告诉别人运行这个项目需要哪些依赖。 main.py：程序的启动入口，初始化 QApplication，就像给汽车点火，让整个程序跑起来。 main_window.py：主界面的 “大管家”，采用模块化设计，以后想加新功能，就像搭积木一样简单。 batch_file_renamer.py：文件重命名业务逻辑的 “神秘组织”，各种复杂的重命名操作都由它来搞定。 二、核心代码解析：揭开魔法的神秘面纱 2.</description></item><item><title>技术博客架构升级：解锁高效写作新体验</title><link>http://blog.xueyao.tech/post/2025/blog-update-articles/</link><pubDate>Fri, 07 Feb 2025 19:18:42 +0000</pubDate><guid>http://blog.xueyao.tech/post/2025/blog-update-articles/</guid><description>最近我对自己的技术博客架构做了一次重要升级，实现了文章内容与静态网站生成器的完全解耦。这个方案让写作回归纯粹，同时保持了自动化部署的优势。以下是具体的实现方案：
🛠️ 方案架构 主仓库：flowstone/flowstone.github.io​
主仓库仅保留静态网站生成器的相关配置，果断移除了所有文章内容。如此一来，主仓库更加简洁，专注于网站生成的核心配置工作，为后续的自动化部署奠定坚实基础。 文章仓库：flowstone/blog-articles​
文章仓库则全心全意地承担起存放 Markdown 格式博文的重任。它就像一个专属的知识宝库，让每一篇文章都能在自己的 “小天地” 里有序存放，便于管理和维护。 自动化桥梁：GitHub Actions 工作流
每日定时同步文章变更，实现自动构建部署 ⚙️ 核心工作流配置 添加了同步文章工作流sync-articles.yml​
name: Content Sync Automation on: push: branches: [main] schedule: - cron: &amp;#39;0 0 * * *&amp;#39; # 每天UTC时间0点同步 workflow_dispatch: jobs: sync-content: runs-on: ubuntu-latest steps: - name: Checkout Main Repo uses: actions/checkout@v3 with: persist-credentials: false - name: Sync Articles Repo uses: actions/checkout@v3 with: repository: flowstone/blog-articles path: content/posts token: ${{ secrets.GITHUB_TOKEN }} - name: Configure Git run: | git config --global user.</description></item><item><title>博客快速迁移到Sourceforge平台</title><link>http://blog.xueyao.tech/post/2024/blog-remove-sourceforge/</link><pubDate>Sat, 24 Feb 2024 19:18:42 +0000</pubDate><guid>http://blog.xueyao.tech/post/2024/blog-remove-sourceforge/</guid><description>描述 因为个人原因，准备把托管在阿里云虚拟主机上的博客迁移到免费的sourceforget平台上， 在迁移中遇到很多问题，一一记录下来。
操作 1.从虚拟主机中下载博客的相关文件(网站源码&amp;amp;数据库) 2.上传网站源码到FTP中 打开Sourceforget网站获取FTP连接信息，可以通过项目中的Admin-&amp;gt;Project Web Hosting-&amp;gt;Documentation,查找到相关FTP配置,如下图
FTP配置中需要注意登录后的文件路径，我已经在图中标出来了
FTP默认路径 FTP主机空间路径 3.同步数据库 通过项目中的Admin-&amp;gt;Project Web Hosting-&amp;gt;MySQL Database，可以查看数据库的相关配置，也可以修改数据库密码，如下图 Sourceforge数据库中有很多限制，需要慢慢的把数据导入,还有此数据库不支持远程连接
4.预览网站 Sourceforge提供二级域名，格式是
项目名.sourceforge.io 项目名.sourceforge.net 两个都可以，访问网站，如下图 5.绑定自定义域名 通过项目中的Admin-&amp;gt;Project Web Hosting-&amp;gt;Vhost DNS,可以配置绑定的自定义域名，如下图 我绑定是自己博客的二级域名,然后在域名的DNS解析系统中配置映射，如果按照我们常理来说，应该绑定CNAME记录flowstone.sourceforge.io,一开始我却实这样配置了，但是域名却没办法正确显示，提示了一些错误，原来是Sourceforge通过cloudflare进行了一些CDN加速，没办法正确解析到真正的服务器地址。
其实它在帮助文档中写了详细的配置，我没有按照它的说明来配置(IP地址固定)，文档如下： 最终DNS解析配置如下： 如果我们按照它的配置，指向自己的域名，就可以看到域名解析生效了，效果如下 值得注意的是当你配置了自定义域名后，Sourceforge提交的二级域名将自己跳转到你的项目目录中，无法查看你的搭建的网站。
注意 在这些操作里，我遇到了另外一个问题，就是我按照上面的操作，打开我的域名，页面竟报出404错误，如下图 就是这个问题，困扰我一天，我一直以为是DNS解析的问题，查询好多资料，也看了官方的一些客户支持问题，从而确定DNS没有配置错误，那是什么问题造成的呢？
说明域名已经找到了服务器，但是指定的目录下并没有我上传的网站源码，真是奇了怪，不科学，我专门去FTP上找了一番，文件也在，最后在一篇博客里发现了问题，原来官方的配置是基于PHP7版本，但是我手贱的把PHP版本改成PHP8,所以域名解析时并没有找到正确路径，也就是说PHP8版本里面有了特殊的配置，我猜想一种是IP的改变，一种是网站源码路径的改变。</description></item></channel></rss>