<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>薛尧笔记</title><link>https://xueyaoblog.on-fleek.app/</link><description>Recent content on 薛尧笔记</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Mon, 17 Feb 2025 19:18:42 +0000</lastBuildDate><atom:link href="https://xueyaoblog.on-fleek.app/index.xml" rel="self" type="application/rss+xml"/><item><title>Oracle 数据库常见操作技巧</title><link>https://xueyaoblog.on-fleek.app/post/2025/20250217-03/</link><pubDate>Mon, 17 Feb 2025 19:18:42 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2025/20250217-03/</guid><description>在企业级应用开发中，Oracle 数据库作为一款功能强大且广泛使用的关系型数据库管理系统，掌握其常见操作技巧对于提升数据处理效率和应用性能至关重要。本文将围绕一系列 Oracle 数据库操作，结合具体代码进行详细解析。
一、数据插入与更新操作 （一）批量插入操作 在实际业务中，当需要向数据库中批量插入数据时，我们可以使用以下 SQL 语句结合 MyBatis 的&amp;lt;foreach&amp;gt;​标签来实现：
INSERT ALL &amp;lt;foreach collection=&amp;#34;list&amp;#34; item=&amp;#34;item&amp;#34; index=&amp;#34;index&amp;#34;&amp;gt; INTO TEST_QUESTION &amp;lt;trim prefix=&amp;#34;(&amp;#34; suffix=&amp;#34;)&amp;#34;&amp;gt; &amp;lt;include refid=&amp;#34;Base_List&amp;#34;&amp;gt;&amp;lt;/include&amp;gt; &amp;lt;/trim&amp;gt; &amp;lt;trim prefix=&amp;#34;VALUES (&amp;#34; suffix=&amp;#34;)&amp;#34;&amp;gt; #{item.qId,jdbcType=VARCHAR}, #{item.infoId,jdbcType=VARCHAR}, #{item.questionContent,jdbcType=VARCHAR}, #{item.answerContent,jdbcType=VARCHAR}, #{item.answerContentEn,jdbcType=VARCHAR}, #{item.questionContentEn,jdbcType=VARCHAR}, #{item.creator,jdbcType=VARCHAR}, #{item.createTime,jdbcType=TIMESTAMP}, #{item.updater,jdbcType=VARCHAR}, #{item.updateTime,jdbcType=TIMESTAMP}, #{item.optionCategory,jdbcType=VARCHAR} &amp;lt;/trim&amp;gt; &amp;lt;/foreach&amp;gt; SELECT 1 FROM DUAL 上述代码中，通过&amp;lt;foreach&amp;gt;​循环遍历集合list​，将每个元素item​的数据插入到TEST_QUESTION​表中。Base_List​中定义了表的列名，通过&amp;lt;include&amp;gt;​标签引入，实现了灵活的列定义复用。
（二）批量更新操作 批量更新数据时，使用 MyBatis 的&amp;lt;update&amp;gt;​标签结合&amp;lt;foreach&amp;gt;​标签：
&amp;lt;update id=&amp;#34;updateBatch&amp;#34; parameterType=&amp;#34;java.util.List&amp;#34;&amp;gt; &amp;lt;foreach collection=&amp;#34;list&amp;#34; item=&amp;#34;item&amp;#34; index=&amp;#34;index&amp;#34; open=&amp;#34;begin&amp;#34; close=&amp;#34;;end;&amp;#34; separator=&amp;#34;;&amp;#34;&amp;gt; update TEST_TABLE &amp;lt;set&amp;gt; tableName = #{item.tableName} &amp;lt;/set&amp;gt; where tableId = item.</description></item><item><title>MyBatis Plus中XML复杂映射，一对多，多中一对一"</title><link>https://xueyaoblog.on-fleek.app/post/2025/20250217-02/</link><pubDate>Mon, 17 Feb 2025 18:18:42 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2025/20250217-02/</guid><description>现实生活中的例子 我们先不看代码，想象一下，你在管理一个学校的信息系统。学校里有老师，每个老师可以教多个班级，这就是典型的一对多关系。而每个班级里又有一个班主任，这就是多中嵌套一对一的关系。在数据库里，这些信息可能存放在不同的表中，而我们要用 Java 代码把它们整合起来。
MyBatis Plus 的resultMap来帮忙 resultMap就是 MyBatis 里用来建立数据库表和 Java 对象之间关系的工具。下面我们通过一段结合学校场景的具体代码，来看看它是怎么工作的，以及是否存在潜在问题。
代码示例 &amp;lt;resultMap id=&amp;#34;teacherSchoolMap&amp;#34; type=&amp;#34;com.school.vo.TeacherVO&amp;#34;&amp;gt; &amp;lt;result column=&amp;#34;TEACHER_ID&amp;#34; jdbcType=&amp;#34;VARCHAR&amp;#34; property=&amp;#34;id&amp;#34;/&amp;gt; &amp;lt;result column=&amp;#34;TEACHER_NAME&amp;#34; jdbcType=&amp;#34;VARCHAR&amp;#34; property=&amp;#34;name&amp;#34;/&amp;gt; &amp;lt;result column=&amp;#34;HIRE_DATE&amp;#34; jdbcType=&amp;#34;TIMESTAMP&amp;#34; property=&amp;#34;hireDate&amp;#34;/&amp;gt; &amp;lt;collection property=&amp;#34;teachingClasses&amp;#34; ofType=&amp;#34;com.school.vo.ClassVO&amp;#34;&amp;gt; &amp;lt;id column=&amp;#34;CLASS_ID&amp;#34; jdbcType=&amp;#34;VARCHAR&amp;#34; property=&amp;#34;id&amp;#34; /&amp;gt; &amp;lt;result column=&amp;#34;CLASS_NAME&amp;#34; jdbcType=&amp;#34;VARCHAR&amp;#34; property=&amp;#34;className&amp;#34; /&amp;gt; &amp;lt;result column=&amp;#34;CREATION_TIME&amp;#34; jdbcType=&amp;#34;TIMESTAMP&amp;#34; property=&amp;#34;creationTime&amp;#34; /&amp;gt; &amp;lt;association property=&amp;#34;classTeacher&amp;#34; javaType=&amp;#34;com.school.vo.TeacherVO&amp;#34; resultMap=&amp;#34;classTeacherMap&amp;#34;&amp;gt; &amp;lt;/association&amp;gt; &amp;lt;/collection&amp;gt; &amp;lt;/resultMap&amp;gt; &amp;lt;resultMap id=&amp;#34;classTeacherMap&amp;#34; type=&amp;#34;com.school.vo.TeacherVO&amp;#34;&amp;gt; &amp;lt;id column=&amp;#34;CLASS_TEACHER_ID&amp;#34; jdbcType=&amp;#34;VARCHAR&amp;#34; property=&amp;#34;id&amp;#34; /&amp;gt; &amp;lt;result column=&amp;#34;CLASS_TEACHER_NAME&amp;#34; jdbcType=&amp;#34;VARCHAR&amp;#34; property=&amp;#34;name&amp;#34; /&amp;gt; &amp;lt;result column=&amp;#34;CONTACT_NUMBER&amp;#34; jdbcType=&amp;#34;VARCHAR&amp;#34; property=&amp;#34;contactNumber&amp;#34; /&amp;gt; &amp;lt;/resultMap&amp;gt; 一对多关系的映射 在上面的代码里，标签就是用来处理一对多关系的。teacherSchoolMap对应的 Java 对象代表一位老师，而teachingClasses是这位老师所教的多个班级，一个老师可以教多个班级，这就是一对多关系。通过property指定 Java 对象里的集合属性名，ofType指定集合里每个元素的类型，MyBatis 就能把数据库里相关的数据，正确地放进这个集合里。</description></item><item><title>手动分页代码解析</title><link>https://xueyaoblog.on-fleek.app/post/2025/20250217-01/</link><pubDate>Mon, 17 Feb 2025 17:18:42 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2025/20250217-01/</guid><description>注意：一般情况下请使用分页插件，特殊情况才能使用手动分页!!!!
在软件开发中，分页功能是非常常见的，它可以将大量数据按一定规则分割成多个页面展示，提高用户体验和系统性能。本文将详细解析一段实现手动分页功能的代码，并探讨其是否存在问题。
代码展示 // 数据总条数 int size = resps.size(); // 分割数据(手动分页) List&amp;lt;QueryDeviceNameResp&amp;gt; queryDeviceNameResps = resps.subList((pageNo - 1) * pageSize &amp;gt; size? size : (pageNo - 1) * pageSize, pageNo * pageSize &amp;gt; size? size : pageNo * pageSize); // 记录数据 page.setRecords(queryDeviceNameResps); // 总条数 page.setTotal(size); // 总页数 page.setPages(size / pageSize + 1); 代码解析 获取数据总条数： int size = resps.size(); 这行代码通过resps.size()获取数据集合resps的总元素个数，即数据总条数。size变量后续用于计算分页相关的参数。
分割数据实现手动分页： List&amp;lt;QueryDeviceNameResp&amp;gt; queryDeviceNameResps = resps.subList((pageNo - 1) * pageSize &amp;gt; size? size : (pageNo - 1) * pageSize, pageNo * pageSize &amp;gt; size?</description></item><item><title>Java 集合数据处理技巧：使用 Stream API 实现多种操作</title><link>https://xueyaoblog.on-fleek.app/post/2025/20250216-02/</link><pubDate>Sun, 16 Feb 2025 19:18:42 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2025/20250216-02/</guid><description>在 Java 开发中，对集合数据进行处理是非常常见的需求，例如去重、排序、分组、求和等。Java 8 引入的 Stream API 为我们提供了一种简洁、高效的方式来处理集合数据。本文将详细介绍如何使用 Stream API 实现多种集合数据处理操作，并给出相应的代码示例。
1. List 根据某个属性去重 在处理 List​ 数据时，有时需要根据对象的某个属性进行去重。可以使用 TreeSet​ 和 Stream​ 来实现这一功能。以下是示例代码：
import java.util.ArrayList; import java.util.Comparator; import java.util.List; import java.util.TreeSet; import java.util.stream.Collectors; // 定义 SKU 类 class SKU { private String gid; public SKU(String gid) { this.gid = gid; } public String getGid() { return gid; } } public class ListDistinctByProperty { public static void main(String[] args) { List&amp;lt;SKU&amp;gt; skuList = new ArrayList&amp;lt;&amp;gt;(); skuList.</description></item><item><title>从手动到自动：代码多平台同步的最终秘籍</title><link>https://xueyaoblog.on-fleek.app/post/2025/20250216-01/</link><pubDate>Sun, 16 Feb 2025 18:18:42 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2025/20250216-01/</guid><description>一、背景与需求 在日常开发中，我习惯将代码存储在 Github 上。然而，由于网络访问的限制，时常会遇到无法访问的情况。为了确保其他用户能够顺利访问我的代码，我期望在向 Github 提交代码时，能够同步将代码推送到多个代码托管平台，如 Gitee、Gitlab、Bitbucket 等。
二、初始方案：本地配置多仓库地址 起初，我通过在本地配置多个仓库地址来实现这一需求，具体命令如下：
git remote add github 仓库地址 git remote add gitee 仓库地址 但是，每次提交代码时，都需要手动依次将代码推送到各个对应的仓库，操作较为繁琐：
git push github main git push gitee main 三、使用 Github Action 实现自动化同步 后来，Github Action 的出现提供了自动化操作的解决方案。我开始使用它来实现多平台同步。不过，在使用多个平台同步功能时，需要事先向每个同步平台申请访问 Token。这些 Token 通常只能显示一次，当开启新的项目时，我常常忘记之前的 Token，导致难以再次配置。
之前使用的同步代码如下：
# Sample workflow for building and deploying a Jekyll site to GitHub Pages name: Push Other Pages on: # Runs on pushes targeting the default branch push: branches: [&amp;#34;main&amp;#34;] # Allows you to run this workflow manually from the Actions tab workflow_dispatch: jobs: # Build job build: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 with: ref: gh-pages fetch-depth: 0 # &amp;lt;-- clone with complete history - name: Sync Repo to Bitbucket uses: heussd/mirror-to-bitbucket-github-action@v2 with: username: flowstone spacename: flowstone repository: flowstone.</description></item><item><title>《Nuxt.js 实战：从放弃到入门》六、打造个性化文字转图片工具：代码详解与实践</title><link>https://xueyaoblog.on-fleek.app/post/2025/20250215-01/</link><pubDate>Sat, 15 Feb 2025 19:18:42 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2025/20250215-01/</guid><description>在当今短视频的时代，将文字转化为图片是一个常见且实用的需求，无论是用于社交媒体分享、设计宣传材料，还是制作个性化的视觉内容。今天，我们就来深入剖析一个使用 Vue 3 和 ElementPlus 构建的文字转图片工具的代码，了解它是如何实现丰富的自定义功能以及图片生成和下载。
整体功能概述 这个工具提供了一个直观的界面，允许用户输入文本，并对生成图片的多个方面进行个性化设置，包括字体样式、大小、颜色，背景颜色、图片尺寸、水印设置和边距设置等。用户设置完成后，可以点击 “生成图片” 按钮，工具会将输入的文本按照预览的样式生成图片，并以 ZIP 文件的形式下载。
代码结构与组件分析 表单输入区域 用户可以在这里输入要转换的文本内容，并对字体样式、大小、颜色，背景颜色、图片尺寸、水印设置和边距设置等进行调整。例如：
&amp;lt;el-form label-width=&amp;#34;100px&amp;#34;&amp;gt; &amp;lt;el-form-item label=&amp;#34;文本内容&amp;#34;&amp;gt; &amp;lt;el-input v-model=&amp;#34;text&amp;#34; type=&amp;#34;textarea&amp;#34; :rows=&amp;#34;4&amp;#34; placeholder=&amp;#34;请输入要转换的文本内容&amp;#34; class=&amp;#34;input-text&amp;#34; /&amp;gt; &amp;lt;/el-form-item&amp;gt; &amp;lt;!-- 其他表单项... --&amp;gt; &amp;lt;/el-form&amp;gt; 预览区域 实时展示根据用户设置生成的图片预览效果，方便用户在生成图片前进行确认。
&amp;lt;div class=&amp;#34;preview-container-wrapper&amp;#34;&amp;gt; &amp;lt;div v-for=&amp;#34;(page, index) in pages&amp;#34; :key=&amp;#34;index&amp;#34; class=&amp;#34;preview-container&amp;#34; :style=&amp;#34;previewStyle(index)&amp;#34;&amp;gt; &amp;lt;div ref=&amp;#34;textCanvas&amp;#34; class=&amp;#34;text-canvas&amp;#34; :style=&amp;#34;textStyle(index)&amp;#34;&amp;gt; {{ page || &amp;#39;预览效果&amp;#39; }} &amp;lt;div class=&amp;#34;watermark&amp;#34; :style=&amp;#34;watermarkStyle()&amp;#34;&amp;gt;{{ watermarkText }}&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; 操作按钮 提供 “生成图片” 按钮，点击后触发图片生成和下载操作。
&amp;lt;el-button type=&amp;#34;primary&amp;#34; @click=&amp;#34;generateImage&amp;#34; :disabled=&amp;#34;!text&amp;#34; class=&amp;#34;generate-button&amp;#34;&amp;gt; 生成图片 &amp;lt;/el-button&amp;gt; 状态定义 使用 ref​ 定义了多个响应式状态，用于存储用户输入的文本、字体样式、背景设置等信息。</description></item><item><title>《Nuxt.js 实战：从放弃到入门》五、还在为图片裁剪发愁？用它吧！</title><link>https://xueyaoblog.on-fleek.app/post/2025/20250214-03/</link><pubDate>Fri, 14 Feb 2025 19:18:42 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2025/20250214-03/</guid><description>功能说明 设计目标：图片裁剪功能页面旨在实现自由裁剪、固定比例裁剪等丰富功能，为用户提供高效、便捷的图片处理体验。页面使用 Element Plus 组件库搭建，确保界面美观且交互易用，提升用户操作的流畅性和满意度。 页面功能： 图片上传区域：支持用户通过拖拽或点击的方式上传图片，仅支持 JPG 和 PNG 格式，文件大小限制为 10MB。 裁剪预览区域：展示上传的图片，并提供可视化的裁剪操作界面，方便用户实时预览裁剪效果。 裁剪参数设置面板：用户可在此设置裁剪比例，包括自由裁剪以及 1:1、4:3、16:9 等常见固定比例，还能进行向左旋转、向右旋转、水平翻转、垂直翻转等操作。 第三方库集成 实现图片裁剪功能依赖cropperjs库，使用以下命令进行安装：
npm install cropperjs ​​
‍
代码实现 创建页面文件：在项目中创建crop.vue文件，用于实现图片裁剪功能页面。 &amp;lt;template&amp;gt; &amp;lt;div class=&amp;#34;container&amp;#34;&amp;gt; &amp;lt;el-card&amp;gt; &amp;lt;template #header&amp;gt; &amp;lt;div class=&amp;#34;text-center&amp;#34;&amp;gt; &amp;lt;span class=&amp;#34;text-xl font-medium&amp;#34;&amp;gt;图片裁剪&amp;lt;/span&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;!-- 图片上传区域 --&amp;gt; &amp;lt;el-upload class=&amp;#34;upload-area&amp;#34; drag :auto-upload=&amp;#34;false&amp;#34; :show-file-list=&amp;#34;false&amp;#34; accept=&amp;#34;image/*&amp;#34; :on-change=&amp;#34;handleFileSelect&amp;#34; &amp;gt; &amp;lt;template #trigger&amp;gt; &amp;lt;div v-if=&amp;#34;!imageUrl &amp;amp;&amp;amp; !isLoading &amp;amp;&amp;amp; !errorMessage&amp;#34; class=&amp;#34;text-center&amp;#34;&amp;gt; &amp;lt;el-icon class=&amp;#34;el-icon--upload mx-auto block&amp;#34;&amp;gt;&amp;lt;upload-filled /&amp;gt;&amp;lt;/el-icon&amp;gt; &amp;lt;div class=&amp;#34;el-upload__text&amp;#34;&amp;gt; 拖拽图片到此处或 &amp;lt;em&amp;gt;点击上传&amp;lt;/em&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;text-sm text-gray-400 mt-2&amp;#34;&amp;gt;支持 JPG、PNG 格式&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;/el-upload&amp;gt; &amp;lt;div v-if=&amp;#34;isLoading&amp;#34; class=&amp;#34;text-center&amp;#34;&amp;gt; &amp;lt;el-icon class=&amp;#34;is-loading&amp;#34; :size=&amp;#34;24&amp;#34;&amp;gt;&amp;lt;loading /&amp;gt;&amp;lt;/el-icon&amp;gt; &amp;lt;div class=&amp;#34;text-gray-600&amp;#34;&amp;gt;正在处理图片.</description></item><item><title>《Nuxt.js 实战：从放弃到入门》四、轻松制作朋友圈九宫格图片</title><link>https://xueyaoblog.on-fleek.app/post/2025/20250214-02/</link><pubDate>Fri, 14 Feb 2025 18:18:42 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2025/20250214-02/</guid><description>功能说明 设计风格：图片分割功能页面将参考某网页的设计风格，使用 Element Plus 组件库实现界面，旨在确保用户体验流畅，同时保证界面的美观性与易用性。 页面功能： 图片上传区域：支持用户将图片直接拖拽到指定区域进行上传，也可点击上传。仅支持 JPG 和 PNG 格式，文件大小限制为 10MB。 分割参数设置：用户可通过输入行数和列数来设置图片分割的参数，行数和列数的取值范围为 1 到 10。 预览区域：提供上传图片的预览以及分割后图片的预览，方便用户查看分割效果。 下载功能：支持将分割后的图片打包成 ZIP 文件进行下载。 ‍
代码实现 创建页面文件：在项目中创建divide.vue文件，用于实现图片分割功能页面。 &amp;lt;template&amp;gt; &amp;lt;div class=&amp;#34;container&amp;#34;&amp;gt; &amp;lt;el-card&amp;gt; &amp;lt;template #header&amp;gt; &amp;lt;div class=&amp;#34;text-center&amp;#34;&amp;gt; &amp;lt;span class=&amp;#34;text-xl font-medium&amp;#34;&amp;gt;图片分割&amp;lt;/span&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;!-- 图片上传区域 --&amp;gt; &amp;lt;el-upload class=&amp;#34;upload-area&amp;#34; drag :auto-upload=&amp;#34;false&amp;#34; :show-file-list=&amp;#34;false&amp;#34; accept=&amp;#34;image/*&amp;#34; :on-change=&amp;#34;handleFileSelect&amp;#34; &amp;gt; &amp;lt;template #trigger&amp;gt; &amp;lt;div v-if=&amp;#34;!imageUrl &amp;amp;&amp;amp; !isLoading &amp;amp;&amp;amp; !errorMessage&amp;#34; class=&amp;#34;text-center&amp;#34;&amp;gt; &amp;lt;el-icon class=&amp;#34;el-icon--upload mx-auto block&amp;#34;&amp;gt;&amp;lt;upload-filled /&amp;gt;&amp;lt;/el-icon&amp;gt; &amp;lt;div class=&amp;#34;el-upload__text&amp;#34;&amp;gt; 拖拽图片到此处或 &amp;lt;em&amp;gt;点击上传&amp;lt;/em&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;text-sm text-gray-400 mt-2&amp;#34;&amp;gt;支持 JPG、PNG 格式&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;/el-upload&amp;gt; &amp;lt;div v-if=&amp;#34;isLoading&amp;#34; class=&amp;#34;text-center&amp;#34;&amp;gt; &amp;lt;el-icon class=&amp;#34;is-loading&amp;#34; :size=&amp;#34;24&amp;#34;&amp;gt;&amp;lt;loading /&amp;gt;&amp;lt;/el-icon&amp;gt; &amp;lt;div class=&amp;#34;text-gray-600&amp;#34;&amp;gt;正在处理图片.</description></item><item><title>《Nuxt.js 实战：从放弃到入门》三、超实用！ 打造图片压缩神器</title><link>https://xueyaoblog.on-fleek.app/post/2025/20250214-01/</link><pubDate>Fri, 14 Feb 2025 16:18:42 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2025/20250214-01/</guid><description>功能说明 设计风格：图片压缩功能页面将参考网络部分网站的设计风格，采用 Element Plus 组件进行开发，以确保界面美观且易用。 页面功能： 拖拽上传区域：支持用户将图片直接拖拽到指定区域进行上传，也可点击上传。 图片压缩选项：通过滑块控制压缩质量，用户可根据需求调整。 批量图片处理功能：支持同时上传和压缩多张图片。 对比预览：提供压缩前后图片的对比预览，方便用户查看效果。 代码实现 创建页面文件：在pages目录下创建compress.vue文件。 &amp;lt;template&amp;gt; &amp;lt;div class=&amp;#34;container&amp;#34;&amp;gt; &amp;lt;el-card&amp;gt; &amp;lt;template #header&amp;gt; &amp;lt;div class=&amp;#34;text-center&amp;#34;&amp;gt; &amp;lt;span class=&amp;#34;text-xl font-medium&amp;#34;&amp;gt;图片压缩&amp;lt;/span&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;!-- 图片上传区域 --&amp;gt; &amp;lt;el-upload class=&amp;#34;upload-area&amp;#34; drag multiple :auto-upload=&amp;#34;false&amp;#34; :show-file-list=&amp;#34;true&amp;#34; accept=&amp;#34;image/*&amp;#34; :on-change=&amp;#34;handleFileSelect&amp;#34; :on-remove=&amp;#34;handleFileRemove&amp;#34; :file-list=&amp;#34;fileList&amp;#34; &amp;gt; &amp;lt;template #trigger&amp;gt; &amp;lt;div v-if=&amp;#34;!isLoading&amp;#34; class=&amp;#34;text-center&amp;#34;&amp;gt; &amp;lt;el-icon class=&amp;#34;el-icon--upload mx-auto block&amp;#34;&amp;gt;&amp;lt;upload-filled /&amp;gt;&amp;lt;/el-icon&amp;gt; &amp;lt;div class=&amp;#34;el-upload__text&amp;#34;&amp;gt; 拖拽图片到此处或 &amp;lt;em&amp;gt;点击上传&amp;lt;/em&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;text-sm text-gray-400 mt-2&amp;#34;&amp;gt;支持 JPG、PNG、WebP 格式&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;/el-upload&amp;gt; &amp;lt;!-- 压缩设置 --&amp;gt; &amp;lt;div v-if=&amp;#34;fileList.length &amp;gt; 0&amp;#34; class=&amp;#34;compression-settings&amp;#34;&amp;gt; &amp;lt;el-form&amp;gt; &amp;lt;el-form-item label=&amp;#34;压缩质量&amp;#34; style=&amp;#34;min-width: 400px;&amp;#34;&amp;gt; &amp;lt;el-row :gutter=&amp;#34;20&amp;#34; style=&amp;#34;width: 100%;&amp;#34;&amp;gt; &amp;lt;el-col :span=&amp;#34;18&amp;#34;&amp;gt; &amp;lt;el-slider v-model=&amp;#34;quality&amp;#34; :min=&amp;#34;1&amp;#34; :max=&amp;#34;100&amp;#34; :format-tooltip=&amp;#34;value =&amp;gt; `${value}%`&amp;#34; @input=&amp;#34;handleQualityChange&amp;#34; /&amp;gt; &amp;lt;/el-col&amp;gt; &amp;lt;el-col :span=&amp;#34;5&amp;#34; :offset=&amp;#34;1&amp;#34; class=&amp;#34;text-right&amp;#34;&amp;gt; &amp;lt;span class=&amp;#34;text-gray-600&amp;#34;&amp;gt;{{ quality }}%&amp;lt;/span&amp;gt; &amp;lt;/el-col&amp;gt; &amp;lt;/el-row&amp;gt; &amp;lt;/el-form-item&amp;gt; &amp;lt;el-button type=&amp;#34;primary&amp;#34; @click=&amp;#34;compressImages&amp;#34; :loading=&amp;#34;isLoading&amp;#34; :disabled=&amp;#34;fileList.</description></item><item><title>《Nuxt.js 实战：从放弃到入门》二、公共头部脚部组件创建及 Element Plus 集成</title><link>https://xueyaoblog.on-fleek.app/post/2025/20250213-02/</link><pubDate>Thu, 13 Feb 2025 19:18:42 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2025/20250213-02/</guid><description>在项目开发过程中，引入公共头部和脚部组件，有助于实现页面布局的统一，提升用户体验。以下是具体的实施步骤和相关代码。
首先，需要创建一个目录，用于存放相关组件文件，为项目文件结构提供清晰的组织方式。
​​
创建 Header.vue 组件
Header.vue 组件定义了页面的公共头部部分，包含导航链接等内容。其代码如下：
&amp;lt;template&amp;gt; &amp;lt;header class=&amp;#34;bg-white shadow-sm&amp;#34;&amp;gt; &amp;lt;nav class=&amp;#34;container mx-auto px-4 py-3&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;flex items-center justify-between&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;flex items-center space-x-4&amp;#34;&amp;gt; &amp;lt;NuxtLink to=&amp;#34;/&amp;#34; class=&amp;#34;text-xl font-bold text-gray-800&amp;#34;&amp;gt;OutEasy&amp;lt;/NuxtLink&amp;gt; &amp;lt;div class=&amp;#34;hidden md:flex space-x-4&amp;#34;&amp;gt; &amp;lt;NuxtLink to=&amp;#34;/resize&amp;#34; class=&amp;#34;text-gray-600 hover:text-gray-900&amp;#34;&amp;gt;图片调整&amp;lt;/NuxtLink&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/nav&amp;gt; &amp;lt;/header&amp;gt; &amp;lt;/template&amp;gt; ​创建 Footer.vue 组件
Footer.vue 组件定义了页面的公共脚部部分，包含版权信息和相关链接。其代码如下：
&amp;lt;template&amp;gt; &amp;lt;footer class=&amp;#34;bg-gray-50 border-t&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;container mx-auto px-4 py-6&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;flex flex-col items-center justify-center space-y-2&amp;#34;&amp;gt; &amp;lt;p class=&amp;#34;text-gray-600 text-sm&amp;#34;&amp;gt;&amp;amp;copy; 2024 OutEasy. All rights reserved.</description></item><item><title>《Nuxt.js 实战：从放弃到入门》一、项目初始，图片尺寸缩放</title><link>https://xueyaoblog.on-fleek.app/post/2025/20250213-01/</link><pubDate>Thu, 13 Feb 2025 18:18:42 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2025/20250213-01/</guid><description>环境准备 在开始之前，确保你的开发环境已经安装了以下工具：
Node.js：建议安装最新的 LTS 版本，可以从 Node.js 官网 下载安装。 npm 或 yarn：npm 会随着 Node.js 一起安装，yarn 可以通过 npm install -g yarn​ 进行全局安装。 同时，为了方便管理 Node.js 版本，推荐安装 nvm​（Node Version Manager），安装命令如下：
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.5/install.sh | bash 安装完成后，重新打开终端或者执行 source ~/.nvm/nvm.sh​ 使其生效。
‍
创建 Nuxt.js 项目 环境搭建好后，就可以开始创建 Nuxt.js 项目啦。打开终端，依次执行下面这些命令：
mkdir outeasy cd outeasy npx nuxi@latest init npm install 这些命令分别是什么意思呢？
mkdir outeasy：创建一个名为outeasy的文件夹，用来存放我们的项目文件。 cd outeasy：进入刚刚创建的outeasy文件夹，后续的操作都在这个目录下进行。 npx nuxi@latest init：使用 npx 工具调用 nuxi ，把当前目录初始化为一个 Nuxt.js 项目。npx是 npm 5.2.0 引入的一个工具，它能直接运行依赖包，不用提前全局安装。 npm install：安装项目所需要的各种依赖包。这些依赖包是项目运行必不可少的，比如 Nuxt.</description></item><item><title>关于FSGithubPNG生成外链时描述出现路径问题</title><link>https://xueyaoblog.on-fleek.app/post/2025/20250211-02/</link><pubDate>Tue, 11 Feb 2025 19:18:42 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2025/20250211-02/</guid><description>之前在FSGithubPNG上添加一个新的功能，就是上传图片后生成的外链可以是Markdown格式的图片链接，
如下：
![美丽的风景](https://example.com/path/to/your/image.jpg) 图片描述在不同系统下的差异 在 macOS 系统中，图片外链的图片描述为图片名称；而在 Windows 系统中，图片描述为带全路径的名称，如下所示：
![C:\Users\ADMINI~1\AppData\Local\Temp\tmp_rqboyon.png](https://cdn.jsdelivr.net/gh/ueYao/image-hosting@main/blog/2025/02/20250212202236212250.png) ​​
我希望上述的图片外链中描述只应该有图片的名称，原始代码如下：
# 获取当前日期 now = datetime.datetime.now() year = str(now.year) month = str(now.month).zfill(2) # 生成唯一文件名 original_name = self.file_path.split(&amp;#34;/&amp;#34;)[-1] extension = original_name.split(&amp;#34;.&amp;#34;)[-1] unique_name = f&amp;#34;{CommonUtil.get_current_time_str()}.{extension}&amp;#34; base_folder = self.github_root_folder target_path =f&amp;#34;{base_folder}/{year}/{month}/{unique_name}&amp;#34; if base_folder else f&amp;#34;{year}/{month}/{unique_name}&amp;#34; 之前是取original_name为图片的描述，但是现在已经用unique_name代替原来的文件名，
if response.status_code == 201: download_url = response.json().get(&amp;#34;content&amp;#34;).get(&amp;#34;download_url&amp;#34;) if self.github_cdn_checked: image_url = download_url.replace(&amp;#34;https://raw.githubusercontent.com/&amp;#34;, &amp;#34;https://cdn.jsdelivr.net/gh/&amp;#34;).replace(f&amp;#34;{self.github_repo}/&amp;#34;, f&amp;#34;{self.github_repo}@&amp;#34;) logger.info(f&amp;#34;CDN 加速jsDelivr：{image_url}&amp;#34;) else: image_url = download_url logger.info(f&amp;#34;上传成功！图片外链：{image_url}&amp;#34;) if self.github_markdown_checked: # 原始代码 #image_url = f&amp;#34;!</description></item><item><title>还在用 Cursor？免费用 Trae 打造贪吃蛇游戏</title><link>https://xueyaoblog.on-fleek.app/post/2025/20250211-01/</link><pubDate>Tue, 11 Feb 2025 18:18:42 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2025/20250211-01/</guid><description>各位程序员小伙伴们，还在为寻找高效的代码生成工具而发愁吗？今天给大家介绍一款能替代 Cursor 的神器 ——Trae，它是一款强大的 AI 代码生成器。目前，Trae 官网仅提供 MacOS 系统的安装包，Mac 用户们有福啦！
​​
一、下载与安装 第一步，当然是下载安装 Trae。这一步很简单，就像平常安装其他软件一样，从官网获取安装包后，按照提示一步步操作即可。
​​
二、欢迎界面与主题配置 安装完成后，打开 Trae，首先映入眼帘的是欢迎界面，它就像一个热情的向导，引导你开启代码之旅。
​​
接着，你可以根据自己的喜好配置主题，亮色主题适合白天，暗色主题则在夜间更护眼，让你的代码编辑环境更加舒适。
​​
三、跳过配置导入，登录账号 这时，Trae 会询问是否需要导入之前 VS Code、Cursor 的配置，我们先跳过这一步，直接进入后续操作。
​​
然后，需要使用 Github 授权登录，这样才能充分使用 Trae 的各项功能。
​​
四、熟悉默认界面，选择 Builder 登录成功后，我们看到的是软件的默认界面，简洁明了，各个功能区域一目了然。
​​
因为我们要使用自动编写代码功能，所以选择 Builder。Builder 提供了两个默认示例，方便我们快速上手。
​​
五、生成贪吃蛇游戏项目 我选择生成贪吃蛇游戏，结果 AI 提示我没有打开存放游戏的文件夹。
​​
于是，我新建了一个 Greedy-Snake 目录，贪吃蛇游戏将在这个目录下创建。
​​
接着，AI 开始工作，它自动选定了合适的语言和框架，并开始初始化项目。
​​
AI 生成的文件，需要用户点击接受才能保存到目录中，这是为了确保我们对生成的代码有控制权。
​​
很快，一个 Node.js 项目就生成好了，目录下的文件结构也随之呈现。在整个过程中，我们只需根据 AI 的提示进行操作，非常简单。
​​
六、运行游戏及功能优化 最后，我们来运行游戏，看看效果如何。结果发现游戏速度太快，我这手速根本跟不上，很快就 “Game Over” 了，不过游戏结束弹框倒是正常出现。
​​
速度太快了，很快就GG了，游戏结束弹框也有</description></item><item><title>借助 Deepseek，30 分钟打造超实用 GitHub 图床应用</title><link>https://xueyaoblog.on-fleek.app/post/2025/20250209-01/</link><pubDate>Sun, 09 Feb 2025 19:18:42 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2025/20250209-01/</guid><description>在蛇年新春之际，我想和大家分享一个有趣的项目成果。这是一款基于 FS-Tool-Pro 项目代码改造而成的 GitHub 图床应用。借助 Deepseek 工具，我仅仅通过一些简单的提示，利用其生成的代码，经过 30 分钟的测试，这款简洁实用的应用就成功诞生了。
下面为大家展示一下应用的相关界面：
主界面：
​​
配置界面：
​​
GitHub 仓库页面：
​​
‍
再给大家介绍一下项目的目录结构，让大家对项目的组织方式有更清晰的了解：
FSGithubPNG/ # 项目根目录 ├── build.sh # 构建脚本，用于清理和打包项目 ├── app.py # 项目的主入口文件，包含主要的程序逻辑 ├── src/ # 源代码目录，包含项目的主要Python代码 │ ├── main_window.py # 主窗口相关代码，定义主窗口的初始化和操作方法 │ ├── about_window.py # 关于窗口相关代码，定义关于窗口的初始化和布局 │ ├── log_window.py # 日志窗口相关代码，处理日志的显示和关闭事件 │ ├── util/ # 工具类目录，包含各种实用工具类和函数 │ │ ├── common_util.py # 通用工具类，提供一些常用的静态方法，如获取外部路径等 │ │ ├── menu_bar.py # 菜单栏相关代码，处理菜单栏的显示和操作 │ │ ├── app_init_util.py # 应用初始化工具类，负责初始化配置文件、加载样式表和字体等 │ │ ├── option_general.</description></item><item><title>炸裂！AI 工具打造的个人桌面应用，功能大揭秘！</title><link>https://xueyaoblog.on-fleek.app/post/2025/20250208-05/</link><pubDate>Sat, 08 Feb 2025 19:18:42 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2025/20250208-05/</guid><description>想必你已经看过我撰写的《PySide6 项目开发全攻略》系列文章。虽说目前该系列仅发布了两篇，但如果你有进一步的需求，我很乐意继续更新相关内容。
接下来，为你介绍一款我基于 PySide6 开发的应用程序。最初，这款应用是使用 tkinter​ 框架搭建的，不过由于 tkinter​ 构建的 UI 过于简单，难以满足实际需求，我最终决定迁移至 PySide6 框架进行开发。值得一提的是，本工具的代码主要由豆包、ChatGPT、DeepSeek 等 AI 工具生成，而我更多地扮演了代码搬运工的角色，应用支持Win/MacOS系统。
以下是该工具的界面展示：
​​
主界面集成了丰富多样的功能模块，涵盖透明时间、快捷便签、生成器工具、图片工具、文件工具、HASH 校验、网络工具等。下面为你详细介绍各个功能模块及其对应的界面：
透明时间配置界面 该界面可生成具有透明背景的时间显示，同时支持计时器和倒计时功能。
​​
实际效果如下：
​​
快捷便签 如同桌面的临时草稿纸，方便你随时记录重要信息。
​​
生成器工具 包含密码生成、个性密码生成（推荐使用）以及 RSA 密钥生成等实用功能。
​​
​​
​​
图片工具 提供图片转换、批量 HEIC 转 JPG 以及隐水印（存在 BUG）等功能。
​​
文件工具 具备重命名文件夹 / 文件、文件生成、文件比较、AES 加密等一系列文件处理功能。
​​
​​
​​
HASH 校验 用于对文件进行 HASH 校验。
​​
网络工具 包括端口扫描、干掉端口等功能，其中查询 IP 操作涉及联网请求
​​
文件签名 支持文件签名操作。
​​
快速发送 可在局域网内的设备之间快速传输文件，此外还隐藏了 Flask 服务。
​​</description></item><item><title>解锁AnythingLLM与DeekSeek：AI探索新征程</title><link>https://xueyaoblog.on-fleek.app/post/2025/20250208-04/</link><pubDate>Sat, 08 Feb 2025 18:18:42 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2025/20250208-04/</guid><description>你是否曾想拥有一位全能 AI 伙伴，不仅能陪你畅聊、答疑解惑，还能根据你的独特需求，定制专属知识库，成为你的“超级大脑”？如今，随着人工智能的飞速发展，这一愿景已然成为现实。今天，让我们走进 AnythingLLM 与 DeekSeek 的智能世界，探索如何利用它们打造属于自己的 AI 助手。
AI 时代的新星：AnythingLLM 在人工智能的广阔天地中，AnythingLLM 犹如一颗璀璨新星，为我们打开了通向无限可能的大门。作为一款全功能 AI 应用程序，AnythingLLM 以强大的兼容性与定制性著称。你既可以选择接入成熟的商用大语言模型，借助其广博的知识获取精准解答；也可以采用开源模型，进行个性化调整，让 AI 真正成为你的专属智囊。
​​
AnythingLLM 的核心功能 多用户支持与权限管理
无论是个人使用还是团队协作，AnythingLLM 都能适配自如。它支持多用户同时访问，并提供精细的权限管理，使管理员、经理和普通用户各司其职，确保数据安全。 广泛的文档支持
兼容 PDF、TXT、DOCX、XLSX 等多种格式，可处理学术论文、商务报告、会议纪要等，将零散信息整合为可供查询的智能知识库。 智能聊天模式
提供对话模式和查询模式，前者保留上下文，适合深度交流；后者高效定位特定文档内容，满足精准查询需求。 高效与低成本
只需一次嵌入处理，即可长期调用，大幅降低文档处理成本，节约高达 90%。支持多种开源与商用大语言模型，用户可根据需求自由配置。 应用场景 职场助手：上传行业报告、策划方案，获取智能建议，助力团队高效协作。 学习伴侣：存储教材、学术论文，随时查询，成为你的 24 小时在线导师。 生活顾问：管理理财、健康、旅行信息，提供专业建议，让生活更加智慧便捷。 双剑合璧：在 AnythingLLM 中集成 DeekSeek 当 AnythingLLM 遇上 DeekSeek，AI 的智能应用更进一步。通过将 AnythingLLM 作为知识管理平台，并接入 DeekSeek 模型，用户可以定制专属 AI，精准获取个性化答案。
配置步骤 安装 Ollama
访问 Ollama 官网 下载并安装，配置模型存储路径。
​​
下载 DeekSeek 模型
通过 Windows PowerShell 运行 ollama run deepseek-r1:8b​​ 下载模型（不同版本占用空间不同，可依据需求选择）。 ​​</description></item><item><title>手把手教你本地部署Deepseek，开启AI自由探索之旅</title><link>https://xueyaoblog.on-fleek.app/post/2025/20250208-03/</link><pubDate>Sat, 08 Feb 2025 17:18:42 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2025/20250208-03/</guid><description>一、本地部署前的准备工作 1. 硬件要求 Deepseek 的不同版本对硬件要求不同，以下为推荐配置：
模型版本 CPU GPU 内存 存储 DeepSeek-R1-1.5B 4 核以上，Intel/AMD 多核处理器 可选 4GB+ 显存（如 GTX 1650） 8GB+ 3GB+ DeepSeek-R1-7B 8 核以上，现代多核 CPU 8GB+ 显存（如 RTX 3070/4060） 16GB+ 8GB+ DeepSeek-R1-14B 12 核以上 16GB+ 显存（如 RTX 4090） 32GB+ 15GB+ DeepSeek-R1-32B 16 核以上（如 Ryzen 9 / i9） 24GB+ 显存（如 A100 40GB） 64GB+ 30GB+ DeepSeek-R1-70B 32 核以上（服务器级 CPU） 多卡并行（如 2x A100 80GB） 128GB+ 70GB+ 2. 软件环境 操作系统：推荐 Windows、Linux（Ubuntu、CentOS）以获得最佳兼容性。
必备工具：
安装 Ollama（用于管理和运行 Deepseek）：Ollama 官网 二、本地部署步骤 1.</description></item><item><title>爆火的DeepSeek，你真的会用吗？</title><link>https://xueyaoblog.on-fleek.app/post/2025/20250208-02/</link><pubDate>Sat, 08 Feb 2025 16:18:42 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2025/20250208-02/</guid><description>一、引言 最近，AI 界可是被一个名字 “霸屏” 啦，它就是DeepSeek！这货简直像一颗突然冒出来的超级巨星，在全球范围内掀起了一阵 “龙卷风”。不管是刷社交媒体，还是逛科技论坛，到处都能看到大家在热烈讨论 DeepSeek。短短时间，它的下载量就像坐了火箭一样 “蹭蹭” 往上涨，直接在全球 140 多个市场的应用商店排行榜上 “C 位出道”，连曾经风光无限的 ChatGPT 在它面前都有点 “黯然失色” 了。
那么，DeepSeek 到底有啥神奇魔力，能让全球用户都为它 “疯狂打 call”？它真有大家说的那么牛吗？要是你对 DeepSeek 好奇得不行，却又不知道咋上手，那这篇文章可就像是为你量身定制的 “专属攻略” 啦！
二、DeepSeek 是什么？ （一）公司背景 DeepSeek 是 杭州深度求索人工智能基础技术研究有限公司 的简称。这家成立于 2023 年 7 月的公司，由量化资管巨头 幻方量化 创立，是一家专注于 AI 基础技术研究的创新型科技企业。
（二）模型特点 DeepSeek 最大的特点在于它是一款 推理型大模型，与市面上常见的 指令型大模型（如 ChatGPT）截然不同。
指令型大模型 就像一名新入职的实习生，需要你逐步指引，清晰地给出每个步骤，它才能按部就班地执行。例如，你让它写一篇关于人工智能发展的文章，需要告诉它写作结构、内容要点，甚至每个段落的表达方向。 推理型大模型（DeepSeek） 则更像一位经验丰富的资深员工，你只需提供一个目标，它就能自主思考、分析，并产出一篇逻辑清晰、内容丰富的文章。例如，你只需告诉它“写一篇关于人工智能发展趋势的文章”，它就能梳理出 AI 的发展历程、技术突破、应用场景及未来挑战，并生成高质量的内容。 这种能力让 DeepSeek 在许多需要深度思考和逻辑推理的任务中表现得尤为出色。
三、使用准备 （一）下载与安装 DeepSeek 提供 网页版 和 App 版，用户可以根据需求选择合适的版本。
​​
网页版（适合办公、学习）
打开浏览器，在地址栏输入 **https://chat.deepseek.com/**。 按下回车键，即可直接进入 DeepSeek 网页版界面。 界面布局简洁，操作直观，适合快速上手。 App 版（适合移动使用）</description></item><item><title>PySide6 项目开发全攻略：托盘图标&amp;悬浮球</title><link>https://xueyaoblog.on-fleek.app/post/2025/20250208-01/</link><pubDate>Sat, 08 Feb 2025 15:18:42 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2025/20250208-01/</guid><description>一、功能概述与实现思路 本方案通过PySide6实现两个增强功能：
功能介绍 系统托盘图标：当应用窗口最小化时，程序会驻留在系统托盘区域。用户可通过右键点击该图标，呼出包含多种操作选项的菜单，便于快捷操作。 桌面悬浮球：在关闭主界面后，系统会自动生成一个悬浮于桌面的小球。该悬浮球为用户提供了便捷的交互入口，可快速唤起隐藏的主界面。 实现架构：
项目结构 ├── resources/ │ ├── app_mini.ico # 悬浮球图标 │ └── app_tray.ico # 托盘图标 ├── app_mini.py # 悬浮球实现 状态流转示意图：
​​
悬浮球代码实现（app_mini.py）
import sys from PySide6.QtWidgets import QWidget, QVBoxLayout, QLabel from PySide6.QtGui import QMouseEvent, QPixmap, QGuiApplication from PySide6.QtCore import Qt, QTimer class FloatingBall(QWidget): def __init__(self, main_window): super().__init__() # 设置悬浮球背景为透明，增强视觉效果 self.setStyleSheet(&amp;#34;background-color: transparent;&amp;#34;) self.main_window = main_window self.init_ui() def init_ui(self): # 设置窗口标志，使悬浮球无框、始终置顶且不显示在任务栏 self.setWindowFlags(Qt.WindowType.FramelessWindowHint | Qt.WindowType.WindowStaysOnTopHint | Qt.WindowType.Tool) # 设置悬浮球的大小 self.</description></item><item><title>PySide6 项目开发全攻略：打造你的文件重命名神器</title><link>https://xueyaoblog.on-fleek.app/post/2025/pyside-guide-rename/</link><pubDate>Sat, 08 Feb 2025 13:18:42 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2025/pyside-guide-rename/</guid><description>家人们，今天来给大家唠唠如何用 PySide6 打造一个超实用的文件重命名工具。这篇文章适合想搞点 GUI 开发的 Python 小白，也能帮有经验的大佬查漏补缺。话不多说，咱们开整！
一、开发环境搭建：魔法工具大集合 1.1 开发工具 开发前，咱们得先把 “魔法工具” 准备好：
PyCharm 2023.1：这可是 Python 开发的神器，智能代码补全就像你的专属小秘书，敲代码的时候自动提示，效率飞起！还集成了 Qt Designer，可视化界面设计，拖拖拽拽就搞定，简直不要太爽！ Python 3.10：建议大家用虚拟环境，venv 或者 conda 都行。就好比给你的项目穿上一层 “隔离衣”，每个项目都有自己独立的 Python 环境，互不干扰，再也不用担心包冲突的问题啦！ PySide6 6.5.0：Qt 官方钦点的 Python 绑定库，有了它，就能轻松调用 Qt 的各种强大功能，搭建出酷炫的 GUI 界面。 1.2 项目结构：文件的秘密基地 项目结构就像一个有序的小基地，每个文件都有自己的 “小窝”：
FsPySide6Project/ ├──.gitignore # 版本控制的“小卫士”，忽略那些不需要的文件 ├── batch_file_renamer.py # 文件重命名的“大脑”，核心功能都在这儿 ├── main.py # 程序入口，就像房子的大门，从这儿开始你的旅程 ├── main_window.py # 主窗口界面，是你的“门面担当” └── requirements.txt # 依赖清单，记录着项目需要的各种“小帮手” 来看看这些文件都在干啥：
.gitignore：默默守护着项目，把__pycache__/、.idea/ 这些开发环境文件拒之门外，让你的代码仓库干干净净。 requirements.txt：里面写着PySide6&amp;gt;=6.5.0，这是项目的 “粮草清单”，告诉别人运行这个项目需要哪些依赖。 main.py：程序的启动入口，初始化 QApplication，就像给汽车点火，让整个程序跑起来。 main_window.py：主界面的 “大管家”，采用模块化设计，以后想加新功能，就像搭积木一样简单。 batch_file_renamer.py：文件重命名业务逻辑的 “神秘组织”，各种复杂的重命名操作都由它来搞定。 二、核心代码解析：揭开魔法的神秘面纱 2.</description></item><item><title>技术博客架构升级：解锁高效写作新体验</title><link>https://xueyaoblog.on-fleek.app/post/2025/blog-update-articles/</link><pubDate>Fri, 07 Feb 2025 19:18:42 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2025/blog-update-articles/</guid><description>最近我对自己的技术博客架构做了一次重要升级，实现了文章内容与静态网站生成器的完全解耦。这个方案让写作回归纯粹，同时保持了自动化部署的优势。以下是具体的实现方案：
🛠️ 方案架构 主仓库：flowstone/flowstone.github.io​
主仓库仅保留静态网站生成器的相关配置，果断移除了所有文章内容。如此一来，主仓库更加简洁，专注于网站生成的核心配置工作，为后续的自动化部署奠定坚实基础。 文章仓库：flowstone/blog-articles​
文章仓库则全心全意地承担起存放 Markdown 格式博文的重任。它就像一个专属的知识宝库，让每一篇文章都能在自己的 “小天地” 里有序存放，便于管理和维护。 自动化桥梁：GitHub Actions 工作流
每日定时同步文章变更，实现自动构建部署 ⚙️ 核心工作流配置 添加了同步文章工作流sync-articles.yml​
name: Content Sync Automation on: push: branches: [main] schedule: - cron: &amp;#39;0 0 * * *&amp;#39; # 每天UTC时间0点同步 workflow_dispatch: jobs: sync-content: runs-on: ubuntu-latest steps: - name: Checkout Main Repo uses: actions/checkout@v3 with: persist-credentials: false - name: Sync Articles Repo uses: actions/checkout@v3 with: repository: flowstone/blog-articles path: content/posts token: ${{ secrets.GITHUB_TOKEN }} - name: Configure Git run: | git config --global user.</description></item><item><title>博客快速迁移到Sourceforge平台</title><link>https://xueyaoblog.on-fleek.app/post/2024/blog-remove-sourceforge/</link><pubDate>Sat, 24 Feb 2024 19:18:42 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2024/blog-remove-sourceforge/</guid><description>描述 因为个人原因，准备把托管在阿里云虚拟主机上的博客迁移到免费的sourceforget平台上， 在迁移中遇到很多问题，一一记录下来。
操作 1.从虚拟主机中下载博客的相关文件(网站源码&amp;amp;数据库) 2.上传网站源码到FTP中 打开Sourceforget网站获取FTP连接信息，可以通过项目中的Admin-&amp;gt;Project Web Hosting-&amp;gt;Documentation,查找到相关FTP配置,如下图
FTP配置中需要注意登录后的文件路径，我已经在图中标出来了
FTP默认路径 FTP主机空间路径 3.同步数据库 通过项目中的Admin-&amp;gt;Project Web Hosting-&amp;gt;MySQL Database，可以查看数据库的相关配置，也可以修改数据库密码，如下图 Sourceforge数据库中有很多限制，需要慢慢的把数据导入,还有此数据库不支持远程连接
4.预览网站 Sourceforge提供二级域名，格式是
项目名.sourceforge.io 项目名.sourceforge.net 两个都可以，访问网站，如下图 5.绑定自定义域名 通过项目中的Admin-&amp;gt;Project Web Hosting-&amp;gt;Vhost DNS,可以配置绑定的自定义域名，如下图 我绑定是自己博客的二级域名,然后在域名的DNS解析系统中配置映射，如果按照我们常理来说，应该绑定CNAME记录flowstone.sourceforge.io,一开始我却实这样配置了，但是域名却没办法正确显示，提示了一些错误，原来是Sourceforge通过cloudflare进行了一些CDN加速，没办法正确解析到真正的服务器地址。
其实它在帮助文档中写了详细的配置，我没有按照它的说明来配置(IP地址固定)，文档如下： 最终DNS解析配置如下： 如果我们按照它的配置，指向自己的域名，就可以看到域名解析生效了，效果如下 值得注意的是当你配置了自定义域名后，Sourceforge提交的二级域名将自己跳转到你的项目目录中，无法查看你的搭建的网站。
注意 在这些操作里，我遇到了另外一个问题，就是我按照上面的操作，打开我的域名，页面竟报出404错误，如下图 就是这个问题，困扰我一天，我一直以为是DNS解析的问题，查询好多资料，也看了官方的一些客户支持问题，从而确定DNS没有配置错误，那是什么问题造成的呢？
说明域名已经找到了服务器，但是指定的目录下并没有我上传的网站源码，真是奇了怪，不科学，我专门去FTP上找了一番，文件也在，最后在一篇博客里发现了问题，原来官方的配置是基于PHP7版本，但是我手贱的把PHP版本改成PHP8,所以域名解析时并没有找到正确路径，也就是说PHP8版本里面有了特殊的配置，我猜想一种是IP的改变，一种是网站源码路径的改变。</description></item><item><title>About</title><link>https://xueyaoblog.on-fleek.app/about/</link><pubDate>Tue, 20 Feb 2024 21:05:21 +0800</pubDate><guid>https://xueyaoblog.on-fleek.app/about/</guid><description> 每天0点，网站会自动更新，人走站还在，除非Github倒闭!!!
站点 备用网址 Github https://flowstone.github.io/ SourceForge https://flowstoneblog.sourceforge.io/ Surge http://spotted-shelf.surge.sh/ Fleek https://xueyaoblog.on-fleek.app/ Netlify https://xueyao.netlify.app/ Vercel https://xueyao.vercel.app/ 2022年2月17日
我是一名Java程序员，
这个博客我从2016年就创建了，
期间写一些文章，
网站的程序也换了一大批，
从WordPress-&amp;gt;Hexo-&amp;gt;WordPress-&amp;gt;Ghost-&amp;gt;Halo-&amp;gt;Z-Blog,
从上面这个经历，你应该知道我是一个瞎折腾的人，
也就是一般人口中说的无聊的人，
现在我想静下来，专心专注的做一件事，
因本人精力有限，所以文章只会在博客、微信公众号、CSDN同步更新，
平台 昵称 微信公众号 薛尧笔记 CDSN 薛尧笔记 感兴趣的小伙伴可以关注，谢谢！
操作记录 2024年2月21日01:42
因为阿里云虚拟空间越来越贵，
从当初的49元涨到现在253元(10年时间)，
云服务器却便宜了许多，
但是打工人的薪资却没有丝毫变化，
虽然空间和流量变大了，
但是对我这种一年没几人访问的网站来说太贵了，
域名续费也越来越贵，
已经放弃了多个注册7、8年的域名，
这个博客域名会一直续费，因为和邮箱地址是绑定的&amp;hellip;
本站再次回到hugo上来，
网站保存在Github上，
然后再通过Fleek自动同步到IPFS平台上，
文章数据不会再丢失了，
但是网页的响应速度感人，
后期再调整。
/** * 博客DNS已做相关调整 * 通过大陆IP访问会解析到Github Page【废弃】 * 通过外国IP访问会解析到Fleek平台下【废弃】 */ 2024年2月24日16:42
这几天在做的任务是把阿里虚拟主机上的网站,
迁移到Sourceforget.net上，
原博客程序不再更新文章，
只做存档，如果你感兴的话，可以访问以下地址：
2025年2月
更换了主题，加入多个静态网站备份
旧博客地址 http://zblog.xueyao.tech/ https://flowstone.sourceforge.io/ (备用地址)</description></item><item><title>友情链接</title><link>https://xueyaoblog.on-fleek.app/friend/</link><pubDate>Thu, 09 Jun 2022 20:12:52 +0800</pubDate><guid>https://xueyaoblog.on-fleek.app/friend/</guid><description> 本站信息 站名： 薛尧笔记 站长： flowstone 申请方法 添加本站后，在本页留言，格式如下 ```yml - name: #您的名字 url: #您的网址 desc: #简短描述 image: #一张图片 ``` 小伙伴们 D-Sketon Hexo 建站 ToolEasy 网页工具</description></item><item><title>如何实现Oracle先组内排序然后再组外排序</title><link>https://xueyaoblog.on-fleek.app/post/2022/oracle-how-multiple-sorting/</link><pubDate>Fri, 29 Apr 2022 14:18:42 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2022/oracle-how-multiple-sorting/</guid><description>问题描述 工作中遇到一个问题，因为我本人的SQL技术太差了，写了好久，都没有处理好，大概的需求如下，有一个列表，根据一个字段排序，排序后的结果，再根据字段排序。
问题分析 为了让读者能够充分理解这个问题，先分解问题 原始数据如下：
序号 名称 部门 入职时间 等级 1 小明 开发部 2012-10 1 2 小丽 账务部 2013-01 1 3 小华 开发部 2021-01 3 4 小红 开发部 2001-01 2 5 小张 账务部 2022-01 2 1、先根据部门分组，然后根据等级排序(正序) 预期结果如下
序号 名称 部门 入职时间 等级 1 小明 开发部 2012-10 1 2 小红 开发部 2001-01 2 3 小华 开发部 2021-01 3 4 小丽 账务部 2013-01 1 5 小张 账务部 2022-01 2 2、先根据部门分组，然后根据入职排序(倒序) 预期结果如下</description></item><item><title>BUG记录-多线程对事务的影响有多么大？</title><link>https://xueyaoblog.on-fleek.app/post/2021/bug-thread-transaction/</link><pubDate>Thu, 14 Oct 2021 13:33:26 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2021/bug-thread-transaction/</guid><description>问题描述 有一天，测试妹子W向我提了一个BUG，问题描述如下，当操作动作D时，动作D可以看作更新，更新我当前选择的那一条数据，妹子W看到操作D成功页面中多出一条一样的数据，期望的结果是只会更新当前选择行的数据，并不会新增多余的数据。
问题原因 开始的时候，我认为代码有问题，查看一下代码，应该没有太大的问题，普通操作动作D时，数据会更新，不会新增多余的数据，但是在出现异常时，这个问题，就会复现出来，我当前猜想应该有事务有关系。
现在我先说明一下，动作D的业务逻辑，当我们点击动作D时，首先会调用更新操作，更新数据，此处的更新为先删除原先的数据，后重新插入数据，更新结束后，继续向下执行其它逻辑。在我Debug的时候，发现在删除的逻辑上事务有回滚，唯一的是插入数据竟没有回滚，我以为是Mybatis plus有什么特殊的骚操作,原谅当时无知的我，我在Google上找了好多文章就是没找到这个问题产生的原因。最后，只能把这个BUG先放一边，忙着修复其它Bug。
当我把所有的事情都忙完了，我又重新看了动作D的逻辑，看到插入的逻辑，这个插入数据的逻辑我是直接调用同事写好的方法，我看到产生BUG的原因，因为插入的数据有可能有许多，那段的逻辑使用了多线程插入数据。多线程影响事务回滚，事务没办法回滚多线程的数据。
解决步骤 发现问题后，当然要解决问题，多线程影响事务回滚，那我就用最笨的方法，重新写一段插入数据的逻辑，解决这个事务问题。写完代码本地测试，当出现异常时，删除操作回滚数据，新增操作回滚数据，解决完问题，发到测试环境让妹子W再测试一遍，美滋滋！
总结 这个问题，浪费了我许多时间，上网找资料，还有掉头发，最后才发现问题的原因，事实说明我平时粗心大意，没有看清楚代码的逻辑，遇到问题首先不是看代码，而是上网找解决方法。这个坏习惯影响着我，以后的工作中应该避免这类事情的出现。还有一个问题，就是使用别人的代码一定要看中间的逻辑，别人使用没有问题，并不代表你使用那部分代码也没有问题，所以工作中要仔细。</description></item><item><title>如何使用FTP中的模板文件和EasyPOI来导出Excle?</title><link>https://xueyaoblog.on-fleek.app/post/2021/java-ftp-temple-easypoi-export-xls/</link><pubDate>Sun, 25 Jul 2021 13:31:32 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2021/java-ftp-temple-easypoi-export-xls/</guid><description>问题描述 因工作需要导出Excel文件，使用技术为EasyPOI,EasyPOI是一个非常好的导出文件工具，官网提供非常详细的使用文档，在项目中使用EasyPOI的模板导出功能，官方提供的示例代码中，模板的路径都是本地，我使用时也是把Excle模板文件放在本地，因为之前需要导出的地方，不是很多，模板文件放在本地也没有太大问题，但是由于现在需求变更，会有大量的模板需要导出，如果放在本地会造成项目容量变大。现在想把导出的模板保存在远程的FTP服务中，EasyPOI读取FTP的中模板文件生成Excle文件。
解决步骤 1、 查找解决方式 上网找了许多相关资料，官网上也没有找到解决方法，意外浏览了一篇文章，文章中提到了一句话，说EasyPOI读取模板文件，只支持读取本地模板文件，换句话来说，我只需要把FTP中的模板文件下载到本地指定路径，然后，就可以读取模板文件。
2、创建测试项目 创建一个SpringBoot项目，POM文件中引入需要的Jar包，如下
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;cn.hutool&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;hutool-all&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.7.5&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;cn.afterturn&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;easypoi-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.3.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;commons-net&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;commons-net&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.6&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 3、添加一些配置文件
ftp: host: 192.168.2.66 # IP port: 21 # 端口 username: root # 用户名 password: 123456 # 密码 mode: Passive # ftp模式 remotePath: /root/export/ # ftp模板路径 localPath: /Users/simonxue/Developer/Temp/ # 本地模板路径 template: employee: employee.xlsx #模板文件 3、 创建一个FTP下载方法，方法返回地址模板全路径名，如下所示
@Value(&amp;#34;${ftp.host}&amp;#34;) private String host; @Value(&amp;#34;${ftp.port}&amp;#34;) private Integer port; @Value(&amp;#34;${ftp.username}&amp;#34;) private String username; @Value(&amp;#34;${ftp.</description></item><item><title>Ant Design中使用Upload上传组件如何自定义文件列表展示位置</title><link>https://xueyaoblog.on-fleek.app/post/2021/react-ant-upload-component-custom/</link><pubDate>Wed, 17 Feb 2021 13:07:07 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2021/react-ant-upload-component-custom/</guid><description>软件环境 macOS Big Sur 11.1 React 16.12.0 Ant Design 4.10.0 实际效果 现有一个需求，是上传文件，点击浏览文件按钮，选中文件后，在按钮的上方显示，上传的文件列表，如下图所示 当前效果 目前使用阿里的Ant UI组件库，使用其中的上传组件，官方提供的示例，如下图如示 本地使用后，如下图所示 如何才能实现，我们需要的效果呢，Google了好多文章，找到了一种方式，就是重写itemRender方法，自定义文件列表的展示，使用这个方法，需要重写多个action。
后来查看公司前端人员写的代码，看到另一种解决方法。
主要使用两个Upload组件，第一个Upload组件主要是展示文件列表，第二个Upload组件是选择文件上传的这个操作，不过，选择文件后，把文件列表在下方展示隐藏起来。
showUploadList: false, //不显示上传的列表 把得到的文件列表，赋值给第一个Upload组件中，大概如下：
beforeUpload(file: any, fileList: any) { setFileList(fileList); //设置文件列表 return false; //不要调用上传文件接口 }, &amp;lt;!--第一个Upload组件--&amp;gt; &amp;lt;Upload fileList={fileList}&amp;gt;&amp;lt;/Upload&amp;gt; 部分代码如下：
&amp;lt;StyleContent&amp;gt; &amp;lt;StyleMainContent&amp;gt; &amp;lt;Button onClick={btnOnClick} type=&amp;#34;primary&amp;#34;&amp;gt;打开上传&amp;lt;/Button&amp;gt; &amp;lt;Modal visible={isVisible} title=&amp;#34;上传附件&amp;#34; footer={[]} closable&amp;gt; &amp;lt;div style={{ border: &amp;#39;1px solid #ccc&amp;#39;, height: 150, marginBottom: 10 }}&amp;gt; &amp;lt;Upload fileList={fileList} onChange={onChange}&amp;gt;&amp;lt;/Upload&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div style={{ textAlign: &amp;#39;right&amp;#39; }}&amp;gt; &amp;lt;Upload {.</description></item><item><title>React中如何实现文件下载功能</title><link>https://xueyaoblog.on-fleek.app/post/2021/react-design-file-download-function/</link><pubDate>Tue, 05 Jan 2021 13:05:30 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2021/react-design-file-download-function/</guid><description>场景描述 在前端页面中，经常会使用到文件下载功能，我们如何实现下载功能呢？
开发环境 React ^16.12.0 Ant Design ^5.0.12 SpringBoot 2.3.0 问题分析 首先，想到下载，肯定要涉及文件流(字节流)，后端接口返回文件流，前端页面把文件流保存成对应的文件。
后端接口设计 写一个无返回值的方法，方法参数是HttpServletResponse，代码如下所示
//SmsTemplateController.java @GetMapping(&amp;#34;/download&amp;#34;) public void download(HttpServletResponse response) throws IOException { smsTemplateService.download(response); } 接口的具体实现，如下所示
//SmsTemplateServiceImpl.java @Override public void download(HttpServletResponse response) throws IOException { //设置字符集 response.setCharacterEncoding(&amp;#34;utf-8&amp;#34;); //response.setContentType(&amp;#34;application/vnd.ms-excel&amp;#34;); //设置响应的头 response.setHeader(&amp;#34;Content-Disposition&amp;#34;, &amp;#34;attachment;filename = &amp;#34; + &amp;#34;helloworld.png&amp;#34;); //获得响应的字节流 OutputStream outputStream = response.getOutputStream(); //文件写死，根据需求改变 File file = new File(&amp;#34;/Users/simonxue/Developer/Temp/file.png&amp;#34;); //把文件内容复制到字节输出流中 FileIoUtil.copyFile(file, outputStream); } 我们的文件流主要是放在接口响应中，其中涉及到一个工具类，如下所示
//FileIoUtil.java /** * 复制file中的内容到输出流中 * @param file 文件内容 * @param out 输出流 * @throws IOException */ public static void copyFile(File file, OutputStream out) throws IOException { InputStream input = null; try { input = new FileInputStream(file); byte[] buf = new byte[1024]; int bytesRead; while ((bytesRead = input.</description></item><item><title>React中如何实现文件上传功能</title><link>https://xueyaoblog.on-fleek.app/post/2021/react-design-file-upload-function/</link><pubDate>Mon, 04 Jan 2021 13:04:42 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2021/react-design-file-upload-function/</guid><description>场景描述 在前端页面中，经常会使用到文件上传功能，我们如何实现上传功能呢？
开发环境 React ^16.12.0 Ant Design ^5.0.12 SpringBoot 2.3.0 页面实现文件上传 首先我们要用到Ant框架中自带的上传组件Upload，代码如下所示
//index.tsx const props = { //组件的名字，调用接口时传递的名称 name: &amp;#39;file&amp;#39;, //上传前的操作 beforeUpload: (file: any, fileList: any) =&amp;gt; { console.log(&amp;#39;file, fileList&amp;#39;, file, fileList); //上传的文件列表 setFileList(fileList); //返回false 代表暂停上传 需要我们自己实现 return false; }, }; //下面代码是上传按钮 &amp;lt;Upload {...props}&amp;gt; &amp;lt;Button icon={&amp;lt;UploadOutlined /&amp;gt;}&amp;gt;选择&amp;lt;/Button&amp;gt; &amp;lt;/Upload&amp;gt; 上述代码，可以实现一个上传功能，但是还没有和后端有交互，效果图如下 我们再添加一个上传按钮，来和后端交互，代码如下所示
//index.tsx &amp;lt;Col style={{ margin: &amp;#39;10px 20px&amp;#39; }}&amp;gt; &amp;lt;Upload {...props}&amp;gt; &amp;lt;Button icon={&amp;lt;UploadOutlined /&amp;gt;}&amp;gt;选择&amp;lt;/Button&amp;gt; &amp;lt;/Upload&amp;gt; &amp;lt;/Col&amp;gt; &amp;lt;Col style={{ margin: &amp;#39;10px 20px&amp;#39; }}&amp;gt; &amp;lt;Button type=&amp;#34;primary&amp;#34; onClick={uploadOnClick}&amp;gt; 上传 &amp;lt;/Button&amp;gt; &amp;lt;/Col&amp;gt; 上传按钮绑定了一个事件uploadOnClick，如下所示</description></item><item><title>JS中绑定方法加括号和不加括号的区别</title><link>https://xueyaoblog.on-fleek.app/post/2021/js-method-add-or-remove-bracket-different/</link><pubDate>Sun, 03 Jan 2021 13:03:55 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2021/js-method-add-or-remove-bracket-different/</guid><description> 问题描述 在React开发中，遇到一个页面不停调用接口问题，如下图所示 问题解决 查找哪里调用了接口，最后在刷新按钮上找到了问题所在，如下所示
&amp;lt;Button type=&amp;#34;text&amp;#34; icon={&amp;lt;ReloadOutlined /&amp;gt;} title=&amp;#34;刷新&amp;#34; onClick={loadData()} /&amp;gt; 按钮的点击事件上绑定了一个方法，loadData这是一个普通的查询接口，问题就是loadData()后面加了一对括号，如果我把括号去掉，问题就可以完美解决了，如下所示
&amp;lt;Button type=&amp;#34;text&amp;#34; icon={&amp;lt;ReloadOutlined /&amp;gt;} title=&amp;#34;刷新&amp;#34; onClick={loadData} /&amp;gt; 问题思考 为什么会出现这个问题？
Google了一会，得到了我想要的答案
onClick中绑定方法加括号：相当于直接把函数的返回值给onClick方法，会直接触发点击事件，不需要用户点击 onClick中绑定方法不加括号：相当于把整个函数赋值给onClick方法，不会触发点击事件，需要用户点击</description></item><item><title>React中useState如何给对象中的某一个属性赋值</title><link>https://xueyaoblog.on-fleek.app/post/2021/react-usestate-with-object-update-one-assignment/</link><pubDate>Sat, 02 Jan 2021 13:03:06 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2021/react-usestate-with-object-update-one-assignment/</guid><description>问题描述 在React文件中使用了useState，定义了查询条件，这个查询条件实际上是一个对象，如下所示
const [requestParam, setRequestParam] = useState({ pageNum: 1, pageSize: 2, startTime: &amp;#34;&amp;#34;, endTime: &amp;#34;&amp;#34;, mobile: &amp;#34;&amp;#34;, sort: &amp;#34;&amp;#34;, sortField: &amp;#34;&amp;#34; }); 这些参数是查询接口的请求参数，在一般情况下，我们只需要更新其中一个属性的值，在使用setRequestParam修改这些值时，会提示需要给所有参数赋值，如何才能更新某一个值呢？
问题解决 通过Google查询了一下，终于在stackoverflow网站上，看到了大佬们的解答，问题是两年前的问题，我从中找一个容易理解答案，如下所示
setRequestParam(param =&amp;gt; ({ ...param, //如果我要改变mobile的值可以这样写 mobile: &amp;#39;13100008888&amp;#39; })); 看到上面的答案，应该知道采用es中的解构赋值来更新某个值</description></item><item><title>React Ant框架中分页的快速使用</title><link>https://xueyaoblog.on-fleek.app/post/2021/fast-use-pagination-in-react-ant/</link><pubDate>Fri, 01 Jan 2021 13:00:01 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2021/fast-use-pagination-in-react-ant/</guid><description>使用环境 React Ant Design SpringBoot Spring Data JPA 前端页面 首先，我们要查看Ant官方文档，一般涉及到分页的页面都是列表查询，在表格组件中找到API，可以从API中看到使用方法，查看文档后，编写代码如下
&amp;lt;Pagination //默认当前页是接口返回的当前页 defaultCurrent={responseParam.pageNum} //每页条数 取得是接口返回的每页条数 pageSize={responseParam.pageSize} //总条数 取得是接口返回的总条数 total={responseParam.count} //指定每页可以显示多少条	pageSizeOptions={[&amp;#34;2&amp;#34;,&amp;#34;4&amp;#34;,&amp;#34;6&amp;#34;]} //是否展示 pageSize 切换器 showSizeChanger /**页码改变的回调，参数是改变后的页码及每页条数 * @param page 改变后页码 * @param pageSize 每页条数 */ onChange={(page: any, pageSize: any) =&amp;gt; { console.log(&amp;#39;page = &amp;#39;, page, pageSize); setRequestParam(param =&amp;gt; ({ ...param, //修改页码 pageNum: page, //修改每页条数 pageSize: pageSize })); }}/&amp;gt; requestParam定义格式如下:
const [requestParam, setRequestParam] = useState({ //给页码默认值 pageNum: 1, //每页条数默认值 pageSize: 10 }); 当每次我们修改requestParam的值时，就会重新调用接口渲染页面，如下所示:</description></item><item><title>2020年终总结</title><link>https://xueyaoblog.on-fleek.app/post/2020/year-2020/</link><pubDate>Thu, 31 Dec 2020 12:48:14 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2020/year-2020/</guid><description> 前言 回首过去，展望未来，把今年的工作和生活做一个简单的总结，为2020年画上一个美丽的句号。
内容 疫情 离职 起航 疫情 今年是一个充满灾难的一年，春节前，武汉爆发疫情，国家很快的反应过来，对武汉实行封锁，我们春节也不允许出门。到假日结束后，因为多地出现问题，县里的所有交通工具全部停运，也不能去上海，政府也出台了政策，延长假日，我也安心的待在家里，安安静静的过着日子。因为在放假的时候猫放在上海的出租室里，非常担心，害怕猫粮不够，猫会出点意外，所以我提前几天来到上海。出发的时候，我姐姐和姐夫送我到高铁站，那个时候只有高铁能够到上海，中途还要在徐州换乘，终于经过几个小时，我到达了上海，上海路边上的行人非常少，我到了出租屋后，看到了巧克力(猫的名字)还活着，终于放下了我心中的大石头。因为疫情原因，我买了好多方便面，也没有出家门，整天待在家里看电视，期间也拍了些VLOG,目前已经有1000个粉丝。期间一直在家办公，4月才去公司上班。
离职 我们公司技术团队在上海，而总部在青岛，因为此次疫情的影响，公司的业务有一定的缩水，公司决定技术团队回到总部，我在上海待了几年，不想去那么远的地方，而且，青岛离我家太远了，实在不想离家太远，也就离职了。不知道，我走后公司楼下的猫咪们怎么办？
起航 经过n+1次面试后，收到了s-1个offer,我选择了一家公司，公司离我住的地方很近，不过年后，要搬到很远的地方，我也要搬家。新的公司里大佬有很多，也用到了许多流行的技术栈。现在正在慢慢的融入到团队中，团队氛围不错，正在努力学习中&amp;hellip;
总结 今年很失败，去年的所有目标都没有实现，是不是我的目标太高了，在今年找工作的过程中，感觉高并发知识问得最多，然而开发过程中很少能够使用到，我也不太会，如果会的话，应该能够进更好的公司。
2021年计划 创建一个开源项目(博客) 写设计模式文章 看完Java核心技术(卷1) 写SpringCloud文章 学习英语</description></item><item><title>2019年终总结</title><link>https://xueyaoblog.on-fleek.app/post/2019/year-2019/</link><pubDate>Tue, 31 Dec 2019 12:46:41 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2019/year-2019/</guid><description>前言 为了回首过去，展望未来，把今年的工作和生活做一个小小的总结，为2019年画上一个美丽的句号。
内容 公司倒闭了 自己的房子 单身狗 写技术文章 公司倒闭了 去年中旬入职了xx公司，刚刚开始的时候，看公司的办公场及公司人数规模都很大，觉得公司不差钱。平时的待遇都还可以，说不上好，但也不委屈，和同事相处的也不错。
今年四月中旬，公司开始出现资金问题，工资也开始出现晚发的状况，大家都不知道公司资金出现状况，但是第二个月，到了发放工资的时候又出现状况了，这次只是发放员工的基本工资。大家都知道一些小的公司交税就是按最低工资交的，工资也是有两张卡发放的。这次工资拖了很久，一直到下个月发放工资，但是下个月工资也没有钱发放了，公司开始大力裁员(呵呵，啥补偿都没有)，庆幸的是我没有被裁掉，反而这次没有把我裁掉，让我造成更重的损失。在公司一直拖欠工资的状况下，开始有大部分员工开始主动辞职，辞职的员工多数为新员工。我们老一点的员工，还希望公司能够主动辞退我们，拿点补偿金。但是，公司到后来也没有发上工资，大家也去仲裁了，也去法院申请强制执行，然而并没有什么用处，百来号人几百万的工资，一点都没有看到。公司的高层领导也一直安慰我们，说工资肯定会发的。工资的事情一直拖到了七月，公司连办公场所的租金都没有钱付，最后公司决定搬离这边，换一个新的场所。我们项目组人员也都全部离职了，大家各自的找工作了。没过多久公司就倒闭了，大家的钱都没有拿到，真得是太惨了，三个月的工资，白白浪费了三个月的时间。我现在和上家的同事在新的一家公司里上班，虽然现在公司规模没有上家大，但是开心就好。
自己的房子 今年有自己的房子，啃老的我，在一个二线小城市买了一个小小的房子，也有自己的家，也掏空了父母的钱包，我就是那个败家仔。买房子的事情，让我忙了几个月，正好那个时候公司的危机才刚刚开始，要不然，房子的事情也许会往后延几个月，也说不定。现在房子的事情都弄好了，自己也成为一个房奴了，每个月要还房贷。现在中国的房价真的是很吓人，根本不敢想，虽然国家在调控房价，但是并没有什么太大的用处，有钱人还是很多。在此给大家一个告诫，能买房的尽量早点买，要不然，以后能不能有钱买上房还是个未知数。
单身狗 快到而立之年了，有亲戚和阿姨给我安排相亲，对于相亲我以前也很有抵触，但是现在不是那么抵触，也许是年龄大了。家里人一直在催着，头疼，总体来说相亲不是很好，具体我也不能多说，不可言。
写技术文章 从事开发行业，平时会遇到很多问题，把经常遇到的问题总结一下，放到网上，解决其他人的疑惑。做开发不得不说写技术文章，大家写代码平时说话的机会就少了许多，认识的人也是四周的，如果写点技术文章分享给大家，帮别人解惑和认识新的朋友。我的博客好久就创建了，期间没怎么写文章，真对不起当初自己的热心。所以博客也重新拾起来了，认真的写技术文章。
2020年计划 读书20本
创建一个开源项目
写设计模式系列文章
写SpringCloud系列文章</description></item><item><title>JPA使用-实体类上常用注解</title><link>https://xueyaoblog.on-fleek.app/post/2019/jpa-use-common-annotaion/</link><pubDate>Wed, 11 Dec 2019 12:45:59 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2019/jpa-use-common-annotaion/</guid><description> @SQLDelete 场景描述 JPA中提供了简单的CRUD操作，其中删除操作是物理删除，但是实际应用中，系统中的数据是一种资源，不能直接删除，应该做到逻辑删除，JPA中删除操作是不可取的。
场景示例 调用JPA的删除方法，如下代码所示：
@Test public void testJpaDelete() { //此处根据id删除角色信息 roleRepository.deleteById(1); } 执行上面的测试方法，数据表中主键为1的数据，已经被删除掉，看下JPA的执行SQL如下所示:
delete from role where id=? 此语句为JPA删除操作的默认执行语句。
解决方案 JPA的默认删除方法，并不可取，可以在Role实体上加上@SQLDelete注解，并写SQL语句，如下所示:
@SQLDelete(sql = &amp;#34;update role set is_deleted = 1 where id = ?&amp;#34;) 上面的注解代表着，只要执行JPA的删除操作，执行的SQL语句为我们自己定义的SQL语句。
测试一下 @Test public void testJpaDelete() { roleRepository.deleteById(2); } 结果打印的SQL执行语句，如下所示
update role set is_deleted = 1 where id = ? @DynamicInsert 场景描述 在JPA中添加/更新都是使用save()方法，一般情况下，创建数据表的时候，会给某些字段设置默认的值，避免在插入的时候手动赋值，如创建时间，是否删除等等。
save方法会把没有值的对象，默认赋空值，造成，原数据表的默认值失效。
场景示例 解决方案 @DynamicUpdate</description></item><item><title>代码优化-多态代替IF条件判断</title><link>https://xueyaoblog.on-fleek.app/post/2019/code-optimize-if/</link><pubDate>Sun, 01 Dec 2019 12:45:00 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2019/code-optimize-if/</guid><description>场景描述 在开发的场景中，常常会遇到打折的业务需求，每个用户对应的等级，他们的打折情况也是不一样的。例如普通会员打9折，青铜会员打8.5折，黄金会员打8折等等。在一般开发中最简单的就是判断用户的等级，然后对订单作对应的打折处理。
场景示例 写了一个简单的小示例，如下所示：
//1 代表学生 2老师 3校长 int type = 1; if (1 == type) { System.out.println(&amp;#34;学生笑嘻嘻的说话&amp;#34;); } else if (2 == type) { System.out.println(&amp;#34;老师开心的说话&amp;#34;); } else { System.out.println(&amp;#34;校长严肃的说话&amp;#34;); } 上面的代码，是我们经常的做法，代码少的时候，看起来非常清晰，但是代码多起来或者有了更多的判断条件，那上面的代码会更加的混乱，如果每次有修改，都要改动这部分代码。
解决方法 可以把上面的代码改成多态方式，创建三个类，学生Student,老师Teacher,校长HeadMater，父类为Person，这三个类都实现父类的方法say，如下所示:
Person.class
package me.xueyao.service; /** * @author Simon.Xue * @date 2019-12-01 14:31 **/ public interface Person { void say(); } Student.class
package me.xueyao.service.impl; import me.xueyao.service.Person; import org.springframework.stereotype.Service; /** * @author Simon.Xue * @date 2019-12-01 14:34 **/ @Service public class Student implements Person { @Override public void say() { System.</description></item><item><title>Bug集锦-Spring Cloud Feign调用其它接口报错</title><link>https://xueyaoblog.on-fleek.app/post/2019/bug-spring-cloud-feign-callback-error/</link><pubDate>Sun, 27 Oct 2019 12:44:13 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2019/bug-spring-cloud-feign-callback-error/</guid><description>问题描述 Spring Cloud Feign调用其它服务报错，错误提示如下:Failed to instantiate [java.util.List]: Specified class is an interface。
解决方案 通过查询一些资料，得到的结论，是定义接口传递的参数时，没有用@RequestBody修饰，查看定义接口有用@RequestBogy修饰，Feign的接口实现里没有用@RequestBody修饰，添加后问题就解决了，以后还是要仔细看待每个问题。</description></item><item><title>Java多线程-线程通信</title><link>https://xueyaoblog.on-fleek.app/post/2019/java-thread-communication/</link><pubDate>Tue, 03 Sep 2019 12:42:43 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2019/java-thread-communication/</guid><description>通信的方式 要想实现多个线程之间的协同，如：线程执行先后顺序、获取某个线程执行的结果等等。涉及到线程之间的相互通信，分为下面四类：
文件共享 网络共享 共享变量 JDK提供的线程协调API suspend/resume、wait/notify、park/unpark 文件共享 public class MainTest { public static void main(String[] args) { // 线程1 - 写入数据 new Thread(() -&amp;gt; { try { while (true) { Files.write(Paths.get(&amp;#34;test.log&amp;#34;), content = &amp;#34;当前时间&amp;#34; + String.valueOf(System.currentTimeMillis())); Thread.sleep(1000L); } } catch (Exception e) { e.printStackTrace(); } }).start(); // 线程2 - 读取数据 new Thread(() -&amp;gt; { try { while (true) { Thread.sleep(1000L); byte[] allBytes = Files.readAllBytes(Paths.get(&amp;#34;test.log&amp;#34;)); System.out.println(new String(allBytes)); } } catch (Exception e) { e.</description></item><item><title>Java多线程-线程中止</title><link>https://xueyaoblog.on-fleek.app/post/2019/java-thread-stop/</link><pubDate>Mon, 26 Aug 2019 12:41:06 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2019/java-thread-stop/</guid><description>不正确的线程中止-Stop Stop:中止线程，并且清除监控器锁的信息，但是可能导致 线程安全问题，JDK不建议用。 Destroy: JDK未实现该方法。
/** * @author simon */ public class StopThread extends Thread { private int i = 0, j = 0; @Override public void run() { synchronized (this) { // 增加同步锁，确保线程安全 ++i; try { // 休眠10秒,模拟耗时操作 Thread.sleep(10000); } catch (InterruptedException e) { e.printStackTrace(); } ++j; } } /** * 打印i和j */ public void print() { System.out.println(&amp;#34;i=&amp;#34; + i + &amp;#34; j=&amp;#34; + j); } } /** * @author simon * 示例3 - 线程stop强制性中止，破坏线程安全的示例 */ public class Demo { public static void main(String[] args) throws InterruptedException { StopThread thread = new StopThread(); thread.</description></item><item><title>Java多线程-线程状态</title><link>https://xueyaoblog.on-fleek.app/post/2019/java-thread-status/</link><pubDate>Sun, 25 Aug 2019 12:40:14 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2019/java-thread-status/</guid><description>线程状态 6个状态定义：java.lang.Thread.State
New: 尚未启动的线程的线程状态。 Runnable: 可运行线程的线程状态，等待CPU调度。 Blocked: 线程阻塞等待监视器锁定的线程状态。处于synchronized同步代码块或方法中被阻塞。 Waiting: 等待线程的线程状态。下列不带超时的方式：Object.wait、Thread.join、LockSupport.park Timed Waiting: 具有指定等待时间的等待线程的线程状态。下列超时的方式：Thread.sleep、Object.wait、Thread.join、LockSupport.parkNanos、LockSupport.parkUntil 常见线程状态切换 新建-&amp;gt;运行-&amp;gt;终止 Thread thread1 = new Thread(new Runnable() { @Override public void run() { System.out.println(&amp;#34;thread1当前状态：&amp;#34; + Thread.currentThread().getState().toString()); System.out.println(&amp;#34;thread1 执行了&amp;#34;); } }); System.out.println(&amp;#34;没调用start方法，thread1当前状态：&amp;#34; + thread1.getState().toString()); thread1.start(); Thread.sleep(2000L); // 等待thread1执行结束，再看状态 System.out.println(&amp;#34;等待两秒，再看thread1当前状态：&amp;#34; + thread1.getState().toString()); 新建-&amp;gt;运行-&amp;gt;等待-&amp;gt;运行-&amp;gt;终止 Thread thread2 = new Thread(new Runnable() { @Override public void run() { try {// 将线程2移动到等待状态，1500后自动唤醒 Thread.sleep(1500); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&amp;#34;thread2当前状态：&amp;#34; + Thread.</description></item><item><title>Java多线程-程序运行堆栈分析</title><link>https://xueyaoblog.on-fleek.app/post/2019/java-thread-program-run-stack/</link><pubDate>Sun, 25 Aug 2019 12:39:19 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2019/java-thread-program-run-stack/</guid><description>class文件内容 class文件包含JAVA程序执行的字节码；数据严格按照格式紧凑排列在class文件中的二进制流，中间无任何分隔符；文件开头有一个0xcafebabe(16进制)特殊的一个标志。
JVM运行时数据区 线程独占：每个线程都会有它独立的空间，随线程生命周期而创建和销毁 线程共享：所有线程能访问这块内存数据，随虚拟机或者GC而创建和销毁
方法区 JVM用来存储加载的类信息、常量、静态变量、编译后的代码等数据。 虚拟机规范中这是一个逻辑区划。具体实现根据不同虚拟机来实现。 如：oracle的HotSpot在java7中方法区放在永久代，java8放在元数据空间，并且通过GC机制对这个区域进行管理
堆内存 堆内存还可以细分为：老年代、新生代(Eden、From Survivor、To Survivor) JVM启动时创建，存放对象的实例。垃圾回收器主要就是管理堆内存。 如果满了，就会出现OutOfMemoryError。
虚拟机栈 虚拟机栈，每个线程都在这个空间有一个私有的空间。 线程栈由多个栈帧(Stack Frame)组成。 一个线程会执行一个或多个方法，一个方法对应一个栈帧。 栈帧内容包含：局部变量表、操作数栈、动态链接、方法返回地址、附件信息等。 栈内存默认最大是1M，超出则抛出StackOverflowError
本地方法栈 和虚拟机栈功能类似，虚拟机栈是为虚拟机执行JAVA方法而准备的，本地方法栈是为虚拟机使用Native本地方法而准备。 虚拟机规范没有规定具体的实现，由不同的虚拟机厂商去实现。 HotSpot虚拟机中虚拟机栈和本地方法栈的实现方式一样的。同样，超出大小以后也会抛出StackOverflowError。
程序计数器 程序计数器(Program Counter Register)记录当前线程执行字节码的位置，存储的是字节码指令地址，如果执行Native方法，则计数器值为空。 每个线程都在这个空间有一个私有的空间，占用内存空间很少。 CPU同一时间，只会执行一条线程中的指令。JVM多线程会轮流切换并分配CPU执行时间的方式。为了线程切换后，需要通过程序计数器，来恢复正确的执行位置。</description></item><item><title>Java内存缓存-通过Google Guava创建缓存</title><link>https://xueyaoblog.on-fleek.app/post/2019/java-cache-google-guava/</link><pubDate>Fri, 23 Aug 2019 12:37:51 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2019/java-cache-google-guava/</guid><description>谷歌Guava缓存 Guava介绍 Guava是Google guava中的一个内存缓存模块，用于将数据缓存到JVM内存中。实际项目开发中经常将一些公共或者常用的数据缓存起来方便快速访问。
Guava Cache是单个应用运行时的本地缓存。它不把数据存放到文件或外部服务器。如果不符合需求，可以选择Memcached、Redis等工具。
小案例 pom.xml添加guava依赖
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;project xmlns=&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xsi:schemaLocation=&amp;#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;#34;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;groupId&amp;gt;me.xueyao.cache&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;java-demo&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.cache&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;cache-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.1.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.google.guava&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;guava&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;27.0.1-jre&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;/project&amp;gt; GuavaCacheDemo.java 代码如下：
package me.xueyao.cache.java.guava; import com.google.common.cache.*; import me.xueyao.cache.java.pojo.User; import java.util.concurrent.ExecutionException; import java.util.concurrent.TimeUnit; /** * @author simon * https://github.com/google/guava */ public class GuavaCacheDemo { public static void main(String[] args) throws ExecutionException { //缓存接口这里是LoadingCache，LoadingCache在缓存项不存在时可以自动加载缓存 LoadingCache&amp;lt;String, User&amp;gt; userCache //CacheBuilder的构造函数是私有的，只能通过其静态方法newBuilder()来获得CacheBuilder的实例 = CacheBuilder.</description></item><item><title>Java内存缓存-通过Map定制简单缓存</title><link>https://xueyaoblog.on-fleek.app/post/2019/java-cache-map/</link><pubDate>Thu, 22 Aug 2019 12:37:04 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2019/java-cache-map/</guid><description>缓存 在程序中，缓存是一个高速数据存储层，其中存储了数据子集，且通常是短暂性存储，这样日后再次请求此数据时，速度要比访问数据的主存储位置快。通过缓存，可以高效地重用之前检索或计算的数据。
为什么要用缓存 场景 在Java应用中，对于访问频率高，更新少的数据，通常的方案是将这类数据加入缓存中，相对从数据库中读取，读缓存效率会有很大提升。
在集群环境下，常用的分布式缓存有Redis、Memcached等。但在某些业务场景上，可能不需要去搭建一套复杂的分布式缓存系统，在单机环境下，通常是会希望使用内部的缓存(LocalCache)。
方案 基于JSR107规范自研
基于ConcurrentHashMap实现数据缓存
JSR107规范目标 为应用程序提供缓存Java对象的功能。
定义了一套通用的缓存概念和工具。
最小化开发人员使用缓存的学习成本。
最大化应用程序在使用不同缓存实现之间的可移植性。
支持进程内和分布式的缓存实现。
JSR107规范核心概念 Java Caching定义了5个核心接口，分别是CachingProvider, CacheManager, Cache, Entry 和 Expiry。
CachingProvider定义了创建、配置、获取、管理和控制多个CacheManager。一个应用可以在运行期访问多个CachingProvider。
CacheManager定义了创建、配置、获取、管理和控制多个唯一命名的Cache，这些Cache存在于- CacheManager的上下文中。一个CacheManager仅被一个CachingProvider所拥有。
Cache是一个类似Map的数据结构并临时存储以Key为索引的值。一个Cache仅被一个CacheManager所拥有。
Entry是一个存储在Cache中的key-value对。
每一个存储在Cache中的条目有一个定义的有效期，即Expiry Duration。
一旦超过这个时间，条目为过期的状态。一旦过期，条目将不可访问、更新和删除。缓存有效期可以通过ExpiryPolicy设置。
小例子 使用Map来实现一个简单的缓存功能
MapCacheDemo.java
package me.xueyao.cache.java; import java.lang.ref.SoftReference; import java.util.Optional; import java.util.concurrent.ConcurrentHashMap; /** * @author simon * 用map实现一个简单的缓存功能 */ public class MapCacheDemo { /** * 使用 ConcurrentHashMap，线程安全的要求。 * 我使用SoftReference &amp;lt;Object&amp;gt; 作为映射值，因为软引用可以保证在抛出OutOfMemory之前，如果缺少内存，将删除引用的对象。 * 在构造函数中，我创建了一个守护程序线程，每5秒扫描一次并清理过期的对象。 */ private static final int CLEAN_UP_PERIOD_IN_SEC = 5; private final ConcurrentHashMap&amp;lt;String, SoftReference&amp;lt;CacheObject&amp;gt;&amp;gt; cache = new ConcurrentHashMap&amp;lt;&amp;gt;(); public MapCacheDemo() { Thread cleanerThread = new Thread(() -&amp;gt; { while (!</description></item><item><title>Docker进阶-快速扩容</title><link>https://xueyaoblog.on-fleek.app/post/2019/docker-guide-expansion/</link><pubDate>Wed, 21 Aug 2019 12:35:15 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2019/docker-guide-expansion/</guid><description>1、命令方式 在创建好的Swarm集群中运行nginx服务，并使用&amp;ndash;replicas参数指定启动的副本数。
docker service create --replicas 3 -p 80:80 --name nginx nginx:latest 或者
docker service create -p 80:80 --name nginx nginx:latest docker service scale nginx=3 docker service ls #查看副本情况 2、portainer方式 可以使用portainer的方式在web界面上创建服务并指定副本数，同时可以随时动态增减副本数。</description></item><item><title>Docker入门-docker compose的使用</title><link>https://xueyaoblog.on-fleek.app/post/2019/docker-guide-compose-use/</link><pubDate>Mon, 19 Aug 2019 12:33:56 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2019/docker-guide-compose-use/</guid><description>Compose简介 Compose项目是Docker官方的开源项目，负责实现对Docker容器集群的快速编排。其代码目前在https://github.com/docker/compose 上开源。
Compose定位是定义和运行多个Docker容器的应用，其前身是开源项目Fig。
通过前面内容的介绍，我们知道使用一个Dockerfile模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某任务的情况。例如要实现一个Web项目,除了Web服务容器本身，往往还需要加上后端的数据库服务容器，甚至还包括负载均衡容器等。
Compose恰好满足了这样的需求。它允许用户通过一个单独的docker-compose.yml模板文件来定义一组相关联的应用容器为一个项目(project)。
Compose中有两个重要的概念：
服务(service):一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。 项目(project):由一组关联的应用容器组成的一个完整业务单元。 Compose的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。
Compose项目由Python编写，实现上调用了Docker服务提供的API来对容器进行管理。
安装和卸载 Compose支持Linux、macOS、Windows10三大平台。
Compose可以通过Python的包管理工具pip进行安装，也可以直接下载编译好的二进制文件使用，甚至能够直接在Docker容器中运行。
Docker for Mac、Docker for Windows自带docker-compose二进制文件，安装Docker之后可以直接使用。
docker-compose --version Linux系统需要单独使用二进制或者pip方式进行安装。
Linux安装docker-compose 二进制包 在Linux上的安装十分简单，从官方GitHub Release处直接下载编译好的二进制文件即可。例如，在Linux64位系统上直接下载对应的二进制包。
sudo curl -L &amp;#34;https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)&amp;#34; -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose #赋予可执行权限 PIP安装 如果您计算机的架构是ARM(例如，树莓派),建议使用pip安装。
sudo pip install -U docker-compose 使用 场景：最常见的项目是web网站，一般的web网站都会依赖第三方提供的服务(比如：DB和cache),我们拿dubbo-admin进行讲解(dubbo-admin依赖zookeeper)。
Compose构建dubbo-admin服务 从github上获取dubbo-admin的master分支源码
git clone -b master https://github.com/apache/incubator-dubbo-ops.git 修改admin中的application配置，把zookeeper地址改为zookeeper://zookeeper:2181
使用maven进行编译打包
mvn clean package -Dmaven.test.skip=true 在dubbo-admin目录下编写Dockerfile文件，内容为
# FROM,表示使用JDK8环境为基础镜像，如果镜像不是本地会从DockerHub进行下载 FROM openjdk:8-jdk-alpine # 作者 MAINTAINER Simon&amp;lt;xueyao.</description></item><item><title>Docker入门-数据挂载</title><link>https://xueyaoblog.on-fleek.app/post/2019/docker-guide-data-mount/</link><pubDate>Sun, 18 Aug 2019 12:31:57 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2019/docker-guide-data-mount/</guid><description>Docker数据管理 在容器中管理数据主要有两种方式：
数据卷(Volumes) 挂载主机目录(Bind mounts) 数据卷 数据卷是一个可供一个或多个容器使用的特殊目录，它绕过UFS,可以提供很多有用的特性：
数据卷可以在容器之间共享和重用 对数据卷的修改会立马生效 对数据卷的更新，不会影响镜像 数据卷默认会一直存在，即使容器被删除 注意： 数据卷的使用，类似于Linux下对目录或文件进行mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的数据卷。
Docker中提供了两种挂载方式，-v和-mount
Docker新用户应该选择 &amp;ndash;mount参数
经验丰富的Docker使用者对-v或者&amp;ndash;volume已经很熟悉了，但是推荐使用-mount参数。
创建一个数据卷
docker volume create my-volume 查看指定数据卷的信息
docker volume inspect my-volume 启动一个挂载数据卷的容器：
在用docker run命令的时候，使用&amp;ndash;mount标记来将数据卷挂载到容器里。
创建一个名为session-web的容器，并加载一个数据卷到容器中的/webapp目录。
# 方法一 docker run --name session-web -d -p 8888:8080 --mount source=my-volume,target=/webapp session-web:latest # 方法二 docker run --name session-web -d -p 8888:8080 -v my-volume:/webapp session-web:latest 删除数据卷
docker volume rm my-volume 数据卷是被设计用来持久化数据的，它的生命周期独立于容器，Docker不会在容器被删除后自动删除数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷。 如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用docker rm -v这个命令。
无主的数据卷可能会占据很多空间，要清理请使用以下命令
docker volume prune 挂载主机目录 使用&amp;ndash;mount标记可以指定挂载一个本地主机的目录到容器中去</description></item><item><title>Docker入门-搭建docker私有仓库</title><link>https://xueyaoblog.on-fleek.app/post/2019/docker-guide-private-repository/</link><pubDate>Fri, 16 Aug 2019 12:30:55 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2019/docker-guide-private-repository/</guid><description>Docker Hub 目前Docker官方维护了一个公共仓库Docker Hub，其中已经包括了数量超过15000个镜像。大部分需求都可以通过在Docker Hub中直接下载镜像来使用。
注册登录 可以在https://hub.docker.com 免费注册一个Docker账号。在命令行执行docker login输入用户名及密码来完成在命令行界面登记Docker Hub。你可以通过docker logout退出登录。
拉取镜像 可以通过docker search命令来查找官方仓库中的镜像，并利用docker pull命令来将它下载到本地。
推送镜像 用户也可以在登录后通过docker push命令来将自己的镜像推送到Docker Hub。
修改本地镜像的名字为账号名/镜像名
上传镜像到公共仓库
上传过后，查看远程公共仓库
私有仓库 有时候使用Docker Hub这样的公共仓库可能不方便，用户可以创建一个本地仓库供私人使用。比如，基于公司内部项目构建的镜像。
docker-registry是官方提供的工具，可以用于构建私有的镜像仓库。
安装运行docker-registry
可以通过获取官方registry镜像来运行。默认情况下，仓库会被创建在容器的/var/lib/registry目录下。可以通过-v参数来将镜像文件存放在本地的指定路径。
docker run --name registry -d -p 5000:5000 --restart=always -v /opt/data/registry:/var/lib/registry registry 在私有仓库上传、搜索、下载镜像
创建好私有仓库之后，就可以使用docker tag来标记一个镜像，然后推送它到仓库。先在本机查看已有的镜像。
docker image ls 使用docker tag将session-web:latest这个镜像标记为127.0.0.1:5000/session-web:latest格式为docker tag IMAGE[:TAG][REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]
docker tag session-web:latest 127.0.0.1:5000/session-web:latest 使用docker push上传标记的镜像
docker push 127.0.0.1:5000/session-web:latest 用curl查看仓库中的镜像
curl 127.0.0.1:5000/v2/_catlog 如果可以看到{&amp;ldquo;repositories&amp;rdquo;:[&amp;ldquo;session-web&amp;rdquo;]},表明镜像已经被成功上传了。
先删除已有镜像，再尝试从私有仓库中下载这个镜像。
docker image rm 127.0.0.1:5000/session-web:latest docker pull 127.</description></item><item><title>Docker入门-构建第一个Java程序</title><link>https://xueyaoblog.on-fleek.app/post/2019/docker-guide-first-java-program/</link><pubDate>Fri, 16 Aug 2019 12:29:49 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2019/docker-guide-first-java-program/</guid><description>Docker入门-构建第一个Java程序 定制镜像 准备一个没有第三方依赖的java web项目，可以参考示例maven结构项目：
session-web.war
把该war上传到安装有docker软件的服务器上宿主目录下。在同级目录创建Dockerfile
touch Dockerfile vim Dockerfile 按照前面文章所学的Dockerfile定制镜像知识来编写Dockerfile文件内容如下：
# 基础镜像使用 tomcat:7.0.88-jre8 FROM tomcat:7.0.88-jre8 # 作者 MAINTAINER simon &amp;lt;xueyao.me@gmail.com&amp;gt; # 定义环境变量 ENV TOMCAT_BASE /usr/local/tomcat # 复制war包 COPY ./session-web.war $TOMCAT_BASE/webapps/ 执行构建：
docker bulid -t session-web:latest . 如果构建成功，则会显示构建的分层信息及结果。
查看tomcat构建结果
构建成功后使用docker images命令查看本地是否有该镜像
查看是否有该镜像
运行镜像 镜像制作好之后我们就要把它运行起来
docker run &amp;ndash;name session-web -d -p 8888:8080 session-web:latest
启动后使用netstat -na|grep 8888 验证端口是否是在监听状态
浏览器中访问http://ip:8888/session-web/user/login
本文中war包在此仓库下https://github.com/flowstone/blog-example-code</description></item><item><title>Docker入门-常用命令</title><link>https://xueyaoblog.on-fleek.app/post/2019/docker-guide-normal-shell/</link><pubDate>Wed, 14 Aug 2019 12:29:00 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2019/docker-guide-normal-shell/</guid><description>Docker镜像操作 Docker运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker会从镜像仓库下载该镜像。
获取镜像 从Docker镜像仓库获取镜像的命令是docker pull。其命令格式为：
docker pull [选项][Docker Registry地址[:端口号]/]仓库名[:标签] 具体的选项可以通过docker pull &amp;ndash;help命令看到，这里我们说一下镜像名称的格式。Docker镜像仓库地址：地址的格式一般是&amp;lt;域名/IP&amp;gt;[:端口号]。默认地址是Docker Hub。仓库名：如之前所说，这里的仓库名是两段式名称，即&amp;lt;用户名&amp;gt;/&amp;lt;软件名&amp;gt;。对于Docker Hub,如果不给出用户名，则默认为library,也就是官方镜像。
docker pull ubuntu:16.04 上面的命令中没有给出Docker镜像仓库地址，因此将会从Docker Hub获取镜像。而镜像名称是ubuntu:16.04,因此将会获取官方镜像library/ubuntu仓库中标签为16.04的镜像。
运行镜像 有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的ubuntu:16.04为例，如果我们打算启动里面的bash并且进行交互式操作的话，可以执行下面的命令。
docker run -it --rm ubuntu:16.04 bash -it:这是两个参数，一个是-i:交互式操作，一个是-t终端。
&amp;ndash;rm:这个参数是说容器退出后随之将其删除
ubuntu:16.04:这是指用ubuntu:16.04镜像为基础来启动容器。
bash:放在镜像名后的是命令，这里我们希望有个交互式shell,因此用的是bash。
最后我们通过exit退出了这个容器。
列出镜像 要想列出已经下载下来的镜像，可以使用docker image ls命令。列表包含了仓库名、标签、镜像ID、创建时间以及所占用的空间。
docker image ls 查看镜像、容器、数据卷所占用的空间。
docker system df 仓库名、标签均为的镜像称为虚悬镜像(dangling image)，显示这类镜像
docker image ls -f dangling=true 一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除
docker image prune 删除本地镜像 如果要删除本地的镜像，可以使用docker image rm命令，其格式为：
docker image rm [选项] &amp;lt;镜像1&amp;gt;[&amp;lt;镜像2&amp;gt;...] 其中，&amp;lt;镜像&amp;gt;可以是镜像短ID、镜像长ID、镜像名或者镜像摘要。
使用docker image ls -q来配置docker image rm，这样可以批量删除希望删除的镜像。</description></item><item><title>Docker入门-介绍和安装</title><link>https://xueyaoblog.on-fleek.app/post/2019/docker-guide-intro-install/</link><pubDate>Wed, 14 Aug 2019 12:27:50 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2019/docker-guide-intro-install/</guid><description>Docker容器 Docker是什么 Docker最初是dotCloud公司创建人Solomon Hykes在法国期间发起的一个公司内部项目，它是基于dotCloud公司多年云服务技术的一次革新，并于2013年3月以Apache2.0授权协议开源，主要项目代码在Github上进行维护。Docker项目后来加入了Linux基金会，并成立推动开放容器联盟(OCI).
Docker使用Google公司推出的Go语言进行开发实现，基于Linux内核的cgroup,namespace,以及AUFS类的Union FS等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称为容器。
Docker在容器的基础上，进行了进一步的封装，从文件系统、网络互联至进程隔离等待，极大的简化了容器的创建和维护。使得Docker技术比虚拟机技术更为轻便、快捷。
Docker和传统虚拟机 传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；
而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。
为什么要使用Docker Docker优势 更高效的利用系统资源 更快速的启动时间 一致的运行环境 持续交付和部署 更轻松的迁移 更轻松的维护和扩展 对比传统虚拟机总结 特性 容器 虚拟机 启动 秒级 分钟级 硬盘使用 一般为MB 一般为GB 性能 接近原生 较弱 系统支持量 单机支持上千个容器 一般几十个 Docker架构 Docker使用客户端-服务器(C/S)架构模式，使用远程API来管理和创建Docker容器。
Docker基本概念 Docker镜像 我们都知道，操作系统分为内核和用户空间。对于Linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持。而Docker镜像(Image),就相当于是一个root文件系统。比如官方镜像centos:7.6就包含了完整的一套centos7.6最小系统的root文件系统。
Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数(如匿名半卷、环境变量、用户等)。镜像不包含任何动态数据，其内容在构建之后也不会被改变。
Docker镜像分层存储 因为镜像包含操作系统完整的root文件系统，其体积往往是庞大的，因此在Docker设计时将其设计为分层存储的架构。镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。
镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。
分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。
Docker容器 镜像(Image)和容器(Container)的关系，就像Java中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。
前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。
容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。
按照Docker最佳实践的要求，容器不应该向其存储内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用Volume数据卷、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。
数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。
Docker仓库 镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry就是这样的服务。
一个Docker Registry中可以包含多个仓库(Repository)；每个仓库可以包含多个标签(Tag)；每个标签对应一个镜像。
通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应软件的各个版本。我们可以通过&amp;lt;仓库名&amp;gt;:&amp;lt;标签&amp;gt;的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以latest作为默认标签。
以centos镜像为例，centos是仓库的名字，其内包含有不同的版本标签，如，6.9，7.5。我们可以通过centos:6.9，或者centos:7.5来具体指定所需哪个版本的镜像。如果忽略了标签，比如centos,那将视为centos:latest。
仓库名经常以两段式路径形式出现，比如study/nginx，前者往往意味着Docker Registry多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体Docker Registry的软件或服务。
Docker Registry公开仓库 常用的Registry是官方的Docker Hub，这也是默认的Registry。除此以外，还有CoreOS的Quay.io，CoreOS相关的镜像存储在这里；Google的Google Container Registry,Kubernetes的镜像使用的就是这个服务。
国内的一些云服务商提供了针对Docker Hub的镜像服务。这些镜像服务被称为加速器。常见的有阿里加速器、DaoCloud加速器等。使用加速器会直接从国内的地址下载Docker Hub的镜像，比直接从Docker Hub下载速度会提高很多。</description></item><item><title>Docker入门-Dockerfile的使用</title><link>https://xueyaoblog.on-fleek.app/post/2019/docker-guide-dockerfile/</link><pubDate>Wed, 14 Aug 2019 12:26:32 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2019/docker-guide-dockerfile/</guid><description>使用Dockerfile定制镜像 镜像的定制实际上就是定制每一层所添加的配置、文件。我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，这个脚本就是Dockerfile。
Dockerfile是一个文本文件，其内包含了一条条的指令，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。
接下来我们以官方nginx镜像为例，使用Dockerfile来定制。
在一个空白目录中，建立一个文本文件，并命名为Dockerfile:
mkdir mynginx cd mynginx touch Dockerfile 其内容为：
FROM nginx RUN echo &amp;#39;&amp;lt;h1&amp;gt; Hello,Docker!&amp;lt;/h1&amp;gt;&amp;#39; &amp;gt;/usr/share/nginx/html/index.html 这个Dockerfile很简单，一共就两行。涉及到了两条指令，FROM和RUN。
FROM指定基础镜像 所谓定制镜像，一定是以一个镜像为基础，在其上进行定制。基础镜像是必须指定的，而FROM就是指定基础镜像，因此一个Dockerfile中FROM是必备的指令，并且必须是第一条指令。在Docker Hub上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如nginx、redis、mysql、tomcat等；可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。
如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如ubuntu、debian、centos、alpine等，这些操作系统的软件库为我们提供了更广阔的扩展空间。
除了选择现有镜像为基础镜像外，Docker还存在一个特殊的镜像，名为scratch。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。
FROM scratch ... 如果你以scratch为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。
对于Linux下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接FROM scratch会让镜像体积更加小巧。使用Go语言开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为Go是特别适应容器微服务架构的语言的原因之一。
RUN执行命令 RUN指令是用来执行命令行命令的。由于命令行的强大能力，RUN指令在定制镜像时是最常用的指令之一。其格式有两种：
shell格式：RUN &amp;lt;命令&amp;gt;
RUN echo &amp;#39;&amp;lt;h1&amp;gt;Hello,Docker~&amp;lt;/h1&amp;gt;&amp;#39; &amp;gt; /usr/share/nginx/html/index.html exec格式： RUN [&amp;ldquo;可执行文件&amp;rdquo;,“参数1”,“参数2”]
RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 RUN make -C /usr/src/redis RUN make -C /usr/src/redis install 上面我们利用Dockerfile定制了nginx镜像，现在我们明白了这个Dockerfile的内容，接下来我们来构建这个镜像。
在Dockerfile文件所在目录执行:
docker build -t nginx:v3 . 从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在Step2中，RUN指令启动了一个容器782d25b7c611,执行了所要示的命令，并最后提交了这一层ba38ff665f57,随后删除了所用到的这个容器782d25b7c611。
启动构建的Nginx
docker run --name nginx-test -p 8081:80 -d nginx:v3 如图所示</description></item><item><title>MySQL中INNER JOIN详解</title><link>https://xueyaoblog.on-fleek.app/post/2019/mysql-inner-join/</link><pubDate>Sun, 19 May 2019 12:25:38 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2019/mysql-inner-join/</guid><description>前言 MySQL中联合查询有join、inner join、left join、right join、full join这五种组成。join和inner join是相等的。一般涉及到多张数据表之前的关联查询，必须要用连接操作符。本次来讲讲inner join的使用。
使用 首先，为了能够形象的展示Inner join的效果，创建两张相关联的数据表，学生表和成绩表
学生表创建语句如下：
create table student( id int not null auto_increment, name varchar(64) not null default &amp;#39;&amp;#39; comment &amp;#39;姓名&amp;#39;, primary key(id) ) charset=utf8mb4 comment &amp;#39;学生表&amp;#39;; 成绩表创建语句如下：
create table score( id int not null auto_increment, student_id varchar(64) not null default &amp;#39;&amp;#39; comment &amp;#39;学生id&amp;#39;, chinese varchar(4) not null default &amp;#39;&amp;#39; comment &amp;#39;中文&amp;#39;, primary key(id) ) charset=utf8mb4 comment &amp;#39;学生表&amp;#39;; 学生表的数据如下：
ID NAME 1 小明 2 小华 3 小丽 4 成绩表数据如下</description></item><item><title>Spring自定义注解详解</title><link>https://xueyaoblog.on-fleek.app/post/2019/spring-custom-annotate/</link><pubDate>Wed, 13 Feb 2019 12:24:52 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2019/spring-custom-annotate/</guid><description>下面是RequestBody注解源码
@Target(ElementType.PARAMETER) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface RequestBody { /** * Whether body content is required. * &amp;lt;p&amp;gt;Default is {@code true}, leading to an exception thrown in case * there is no body content. Switch this to {@code false} if you prefer * {@code null} to be passed when the body content is {@code null}. * @since 3.2 */ boolean required() default true; } 现在讲一讲@RequestBody注解中用到其它注解
@Target注解
从字面上理解这个就是目标的意思，说明@RequestBody注解是作用于哪个上面
ElementType
public enum ElementType { /** Class, interface (including annotation type), or enum declaration */ TYPE, /** Field declaration (includes enum constants) */ FIELD, /** Method declaration */ METHOD, /** Formal parameter declaration */ PARAMETER, /** Constructor declaration */ CONSTRUCTOR, /** Local variable declaration */ LOCAL_VARIABLE, /** Annotation type declaration */ ANNOTATION_TYPE, /** Package declaration */ PACKAGE, /** * Type parameter declaration * * @since 1.</description></item><item><title>Java编程思想学习总结一(一切都是对象)</title><link>https://xueyaoblog.on-fleek.app/post/2019/java-idea-study/</link><pubDate>Thu, 07 Feb 2019 12:24:05 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2019/java-idea-study/</guid><description>存储位置 寄存器 堆栈 存储对象引用，堆栈指针向下移动，分配新的内存，向上移动，释放内存 堆 存储Java对象 常量存储 存储常量值 非RAM存储 存储流对象和持久化对象 基本类型所占存储空间 基本类型 大小 包装器类型 默认值 boolean 16bit Boolean false char 16bit Character ‘\u0000’（null） byte 8bit Byte 0 short 16bit Short 0 int 32bit Integer 0 long 64bit Long 0L float 32bit Float 0.0F double 64bit Double 0.0D 永远不需要销毁对象
执行new来创建对象时，数据存储空间才被分配
static作用于某个字段时，都只有一份存储空间
文档注释 javadoc只能为public和protected成员进行文档注释
@see : 引用其化类
{@link package.class#member label} 用于行内，并且是用label作为超链接
{@docRoot} 该标签产生到文档根目录的相对路径，用于文档树页面的显式超链接
{@inheritDoc} 该标签从当前这个类的最直接的基类中继承相关文档到当前的文档注释中
@version 生成版本
@author 作者信息
@since 该标签允许你指定程序代码最早使用的版本</description></item><item><title>Lombok的使用</title><link>https://xueyaoblog.on-fleek.app/post/2019/tool-lombok-use/</link><pubDate>Sun, 03 Feb 2019 12:23:17 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2019/tool-lombok-use/</guid><description>近期在众多微信公众号中，都看到了许多大牛，写了Lombok的文章，我看了一下，基本上就围绕着如何减少代码来做说明，我来总结一下。
公司现在的项目没有使用Lombok，一些实体类都是我们用IDEA提供的快捷方式生成的，后来，公司新来了一个大牛，看到我们每当在一个实体类中新添加一个属性，就要重新生成一个Getter/Setter方法，浪费了大量的时间，一个实体类改了好多遍。后来，他叫我们使用Lombok插件，这款插件可以在编译的时候生成一些常用的方法，我们就不用那么浪费时间。
公司使用的是Maven包管理工具
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt; &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt; &amp;lt;/dependency&amp;gt; 在使用的编辑器中添加lombok插件，我使用的是IntelliJ IDEA这款软件，国内用的比较多，大家应该知道安装一个插件。
在实体类上添加Lombok相关注解，来实现，生成对应方法
@Getter @Setter @NoArgsConstructor @AllArgsConstructor @RequiredArgsConstructor @Data public class LoginRequest { private String username; private String password; } @Getter 在类上说明生成该类中所有属性的Getter方法
@Setter 在类上说明生成该类中所有属性的Setter方法
上面两个方法，也可以使用在属性上,就是生成属性的Getter/Setter方法
@NoArgsConstructor注解，是生成无参构造方法
@AllArgsConstructor注解，是生成有参构造方法
@RequiredArgsConstructor注解，是生成不能为空属性的构造方法
@Data注解是生成Setter、Getter、toString等常用的方法
一般来说，@Data注解就够我们使用的了，如果有特殊的Getter、Setter需求，则需要自己生成对应的方法。最后，总结一些话，Lombok插件虽然能够帮助我们生成对应的方法，但是我们不能足够的依赖一个插件，如果实体类的属性命名不规范，Lombok生成的方法还是会有一些问题的，往往一个小的问题，是一个潜在的危险，我们应当能避免就避免。
常见问题，当项目运行时，如果某个属性没有Getter、Setter方法时，一定要看一下Lombok插件有没有安装。</description></item><item><title>关于博客说明</title><link>https://xueyaoblog.on-fleek.app/post/2019/about-blog/</link><pubDate>Wed, 23 Jan 2019 12:22:23 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2019/about-blog/</guid><description>创建这个博客已经有好长时间了，期间也没有怎么写文章，感觉对不起自己辛辛苦苦建立这个博客，花了好长时间才找到自己满意的博客主题。
之前，这个博客也写了一些杂七杂八的东西，没有深入了解一门技术，都是像一些操作指南一样。现在有一些想法，能够付出实际行动，PHP相关的文章不会再更新了，现在主攻Java，能够多写一些Java相关的文章。
作者是一个内向，话不多的人，希望以后每个星期能够更新两篇文章，能够提升自己的写作水平。</description></item><item><title>DokuWiki安装问题</title><link>https://xueyaoblog.on-fleek.app/post/2019/bug-dokuwiki-install-problem/</link><pubDate>Thu, 17 Jan 2019 12:21:20 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2019/bug-dokuwiki-install-problem/</guid><description>工作了几年，虽然在程序员这个道路上才算开始，希望以后能够有所成长，为了把平时遇到的技术问题，记录下来，第一个想到的就是写wiki，博客虽然创建了许久，但是没有坚持写下去，在网上找了许多的wiki程序，dokuwiki是最符合的。 但是，下载下来，安装就有许多问题，最主要的是通过浏览器访问dukuwiki目录时，出现问题，图没有保存，找到一段官网的问题
DokuWiki Setup Error The datadir (&amp;#39;pages&amp;#39;) at ./data/pages is not found, isn&amp;#39;t accessible or writable. You should check your config and permission settings. Or maybe you want to run the installer? 原本这个问题，我在官网找到了https://forum.dokuwiki.org/thread/9893,刚开始的时候，看到英文就头疼，随手用Google翻译了一下，没看懂，然后就在网上又重新的搜索许多相似的问题，都没有解决。最后，回过头来，仔细看了一下英文的意思，原来是权限问题，采用它给出的解决方法，完美解决问题。
chmod -R 777 data/ chmod -R 777 lib/ chmod -R 777 conf/ 做开发，英文非常重要。</description></item><item><title>Postman之token动态获取</title><link>https://xueyaoblog.on-fleek.app/post/2018/tool-postman-get-token/</link><pubDate>Tue, 13 Nov 2018 12:20:20 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2018/tool-postman-get-token/</guid><description>目前项目涉及PC及APP端接口共用问题，后台接口给登陆后的用户设置了一个token，接口调用时请求头的参数值必须要动态生成，为了解决这个问题，查看Postman API文档，配置了可以方便后端开发者的Tests脚本，如果你需要，请按下面方式配置。
用户登陆 用户登陆页面的请求头参数为固定不变，如图所示
当填写正确的用户名和密码时，系统用返回如下图的数据，里面携带token的值,如图所示
在用户登陆测试接口页面，在点击Tests，在里面添加下面代码，如图所示：
pm.test(&amp;#34;Status code is 200&amp;#34;, function () { pm.response.to.have.status(200); }); var data = JSON.parse(responseBody); //key值 var key = &amp;#39;要加密的Key&amp;#39;; //current-timestamp var currentTimestamp = new Date().getTime().toString(); //nonce-str var nonceStr = getStr(32); function getStr(len){ len = len || 32; var chars = &amp;#39;1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&amp;#39;; var maxPos = chars.length; var s = &amp;#39;&amp;#39;; for (let i = 0; i &amp;lt; len; i++) { s += chars.charAt(Math.floor(Math.random() * maxPos)); } return s; } //token var token = data.</description></item><item><title>ElasticSearch从入门到放弃(一)-安装&amp;运行</title><link>https://xueyaoblog.on-fleek.app/post/2018/java-elastic-search-install-run/</link><pubDate>Thu, 18 Oct 2018 12:19:00 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2018/java-elastic-search-install-run/</guid><description>这几天看到新闻，说ElasticSearch上市了，真的没有想到这个非常流行的开源项目竟然上市了，这个公司的程序员都走上了财务自由的道路。 以前用过ElasticSearch全文搜索引擎，但是时间长也忘记了差不多了，以前而且还是用的老版本，不知道新版本如何使用，废话不多说了，开始：
本地环境及版本 Java1.8 ElasticSearch6.4.2 kibana6.4.2 步骤 下载ElasticSearch 选择自己操作系统所对应的版本 解压后的目录 进入bin目录下，运行elasticsearch命令 看到下图，就说明elasticsearch启动成功，如果你的电脑是Linux，会提示不允许使用root运行，请使用elasticsearch用户启动程序 浏览器查看http://127.0.0.1:9200,出现下图则说明ElasticSearch启动成功 现在ElasticSearch启动好了，再安装一个图形化操作插件Kibana,原本准备安装Sense，结果安装失败，后来知道，6.4.2版本里已经不支持安装Sense，现在Kibana集成了Sense功能，只需要安装Kibana,下载地址如下 解压Kibana文件到ElasticSearch目录下(个人习惯) 运行Kibana项目(/bin/kibana)，看到下图，红色警告部分，因为ElasticSearch服务没有启动，所以kibana项目报告，心跳检测有没有ElasticSearch服务 当启动ElasticSearch服务，kibana程序检测到有活着的elasticSearch服务，立即注册上 浏览器查看http://127.0.0.1:5601,出现下图则说明Kibana启动成功 总结 ElasticSearch和Kibana安装和运行是非常容易的，但是还有许多细节需要注意，操作系统和ElasticSearch版本都要弄清楚。</description></item><item><title>Spring Cloud入门教程一之Eureka Server</title><link>https://xueyaoblog.on-fleek.app/post/2018/spring-cloud-eureka/</link><pubDate>Sat, 13 Oct 2018 12:18:13 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2018/spring-cloud-eureka/</guid><description>项目环境 MacOS JDK1.8 IntelliJ IDEA 2018.2 Maven 3.5.4 创建项目 采用Spring Initializr创建项目 选择Cloud Discovery-&amp;gt;Eureka Discovery-&amp;gt;项目名称 package me.xueyao; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer; @SpringBootApplication //注解该类是EurekaServer服务 @EnableEurekaServer public class EurekaServerApplication { public static void main(String[] args) { SpringApplication.run(EurekaServerApplication.class, args); } } 配置文件application.yml
eureka: client: service-url: defaultZone: http://localhost:8762/eureka/ register-with-eureka: false #是否在eureka中注册，false不用注册 fetch-registry: false #是否发现注册，不注册 server: enable-self-preservation: false # false表示在此eureka服务器中关闭自我保护模式#server:# port: 8761 #服务端口spring: application: name: eureka-server #应用名 启动项目，在浏览器中输入EurekaServer地址http://127.0.0.1:8761,如果页面能正常显示则说明创建Eureka Server成功</description></item><item><title>IntelliJ IDEA技巧一之隐藏.idea目录</title><link>https://xueyaoblog.on-fleek.app/post/2018/java-intelllij-hidden-idea-dir/</link><pubDate>Thu, 11 Oct 2018 12:17:11 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2018/java-intelllij-hidden-idea-dir/</guid><description> 问题场景 通过IntelliJ IDEA软件创建Java Web项目时，项目目录中总会生成.idea配置目录并在软件界面里显示，影响项目美感，如何在软件界面中隐藏.idea目录呢？
解决方法 打开IDEA软件的设置(Mac是Preferences,Windows是Settings) 点击Editor-&amp;gt;File Types Ignore file and folders中添加.idea;(分号为间隔，以后隐藏文件都在这个地方配置)</description></item><item><title>IntelliJ IDEA意外断电，项目所有文件报错</title><link>https://xueyaoblog.on-fleek.app/post/2018/bug-intellij-shutdown-all-file-error/</link><pubDate>Fri, 14 Sep 2018 12:14:34 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2018/bug-intellij-shutdown-all-file-error/</guid><description>今天同事的台式机突然重新启动了，打开IntelliJ IDEA时，项目中所有文件报错，但是项目可以运行，大概是软件问题，上网找了好多解决方法，都没有解决这个问题，后来，我和他说了，把软件的配置文件删除，他没有删除，怕软件坏了，我只能笑笑不说话。后来，他在网上找到解决方案，我把这个问题记录下来。
1.首先打开IntelliJ IDEA的配置文件，在当前电脑用户文件夹下的.IntelliJIdea2016.3(具体看各自的版本) 2.删除system目录下的caches文件夹，该目录是软件运行时生成的缓存目录，删除后，问题完美解决。其实和我删除整个软件配置文件差不多。</description></item><item><title>2018-09-07-周记</title><link>https://xueyaoblog.on-fleek.app/post/2018/weekday-20180907/</link><pubDate>Fri, 07 Sep 2018 12:13:29 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2018/weekday-20180907/</guid><description>这是博客上的第一篇周记文章，主要是总结一周内的事情及所得到的感悟，希望能够警示自己。以后，每个星期都会写一篇这样的文章，文章不会涉及具体的代码。
本周的主要的事情包括项目1.2版本上线，为了项目能够如期上线，我们项目组人员都非常忙碌，最主要的还是前端有部分JS没有写完，我们后端的接口都写好，也测试过。所以我们后端都很闲，除了我们项目组的高级Java在修改数据库中的数据，我和另外一个后端都在看其它技术。其实说好，尽快上测试环境，让测试人员测试网站的bug,结果拖到星期五才给测试人员测试，让我们测试人员陪我们一起加班。
高级Java叫我们以后写代码要严谨点，数据库必填字段不能为空，而如果插入相同的id,数据库中的数据应该是更新操作。每张表中都应该包括创建时间和更新时间，时间都通过数据库插入。
项目上线当晚，项目部署时，项目出现跨域问题，高级Java和运维解决这个问题。后来项目的后台系统中图片资源要访问，但是公司的项目是部署在阿里云服务器上，公网都可以访问，图片资源比较重要，并不能让其它人随意访问。一开始高级Java和运维想把项目部署到内网服务器。但是，公司项目要给老板看效果，老板不在公司，所以必须要把项目部署到外网，才能够给老板演示效果。我记得许多网站的图片资源都是放在服务上，用户只能通过图片详细路径，才能访问图片资源，如果访问图片的服务器根目录，则出现403，无权限访问。我把这种方式告诉了他们，运维用nginx配置文件，来实现这种效果。后来，部署到正式环境后，测试一下，没有bug，我们就下班了。</description></item><item><title>CPU缓存和内存屏障</title><link>https://xueyaoblog.on-fleek.app/post/2019/java-cup-cache-memory-barrier/</link><pubDate>Fri, 07 Sep 2018 12:13:29 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2019/java-cup-cache-memory-barrier/</guid><description>CPU性能优化手段-缓存 为了提高程序运行的性能，现代CPU在很多方面对程序进行了优化。
例如：CPU高速缓存。尽可能地避免处理器访问主内存的时间开销，处理器大多会利用缓存(cache)以提高性能。
多级缓存 L1 Cache(一级缓存)是CPU第一层高速缓存，分为数据缓存和指令缓存。一般服务器CPU的L1缓存的容量通常在32-4096KB。
L2由于L1级高速缓存容量的限制，为了再次提高CPU的运算速度，在CPU外部放置-高速存储器，即二级缓存。
L3现在的都是内置的。而它的实际作用即是，L3缓存的应用可以进一步降低内存延迟，同时提升大数据量计算时处理器的性能。具有较大L3缓存的处理器提供更有效的文件系统缓存行为及较短消息和处理器队列长度。一般是多核共享一个L3缓存！
CPU在读取数据时，先在L1中寻找，再从L2寻找，再从L3寻找，然后是内存，再后是外存储器。
缓存同步协议 多CPU读取同样的数据进行缓存，进行不同运算之后，最终写入主内存以哪个CPU为准？
在这种高速缓存回写的场景下，有一个缓存一致性协议多数CPU厂商对它进行了实现。
MESI协议，它规定每条缓存有个状态位，同时定义了下面四个状态：
修改态(Modified)-此cache行已被修改过(脏行),内容已不同于主存，为此cache专有；
专有态(Exclusive)-此cache行内容同于主存，但不出现于其它cache中；
共享态(Shared)-此cache行内容同于主存，但也出现于其它cache中；
无效态(Invalid)-此cache行内容无效(空行)。
多处理器，单个CPU对缓存中数据进行了改动，需要通知给其它CPU。也就是意味着，CPU处理要控制自己的读写操作，还要监听其他CPU发出的通知，从而保证最终一致。
CPU性能优化手段-运行时指令重排 指令重排的场景：当CPU写缓存时发现缓存区块正被其他CPU占用，为了提高CPU处理性能，可能将后面的读缓存命令优先执行。
并非随便重排，需要遵守s-if-serial语义
as-if-serial语义的意思指：不管怎么重排序(编译器和处理器为了提高并行度)，(单线程）程序的执行结果不能被改变。编译器，runtime和处理器都必须遵守as-if-serial语义。也就是说：编译器和处理器不会对存在数据依赖关系的操作做重排序。
两个问题 1、CPU高速缓存下有一个问题：
缓存中数据与主内存的数据并不是实时同步的，各CPU(或CPU核心)间缓存的数据也不是实时同步。
在同一个时间点，各CPU所看到同一内存地址的数据的值可能是不一致的。
2、CPU执行指令重排序优化下有一个问题：
虽然遵守了as-if-serial语义，单仅在单CPU自己执行的情况下能保证结果正确。多核多线程中，指令逻辑无法分辨因果关联，可能出现乱序执行，导致程序运行结果错误。
内存屏障 处理器提供了两个内存屏障指令(Memory Barrier)用于解决上述两个问题：
写内存屏障(Store Memory Barrier):在指令后插入Store Barrier,能让写入缓存中的最新数据更新写入主内存，让其他线程可见。强制写入主内存，这种显示调用，CPU就不会因为性能考虑而去对指令重排。
读内存屏障(Load Memory Barrier):在指令前插入Load Barrier,可以让高速缓存中的数据失效，强制从主内存加载数据。强制读取主内存内容，让CPU缓存与主内存保持一致，避免了缓存导致的一致性问题。</description></item><item><title>Docker进阶-容器监控cAdvisor+InfluxDB+Granfana</title><link>https://xueyaoblog.on-fleek.app/post/2019/docker-guide-cadvisor-influxdb-granfan/</link><pubDate>Fri, 07 Sep 2018 12:13:29 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2019/docker-guide-cadvisor-influxdb-granfan/</guid><description>概述 前面文章介绍使用docker compose组合应用并利用scale快速对容器进行扩容。
由于docker compose启动的服务都在同一台宿主机上，对于一个宿主机上运行多个容器应用时，容器的运行情况如：CPU使用率、内存使用率、网络状态、磁盘空间等一系列随时间变化的时序数据信息，都是需要去了解，因此监控是必须的。
容器监控方案选择 对于容器的监控方案可谓多种多样，本身自带命令docker stats命令，Scout,Data Dog,Sysdig Cloud,Sensu Monitoring Framework,CAdvisor等。
通过docker stats命令可以很方便的看到当前宿主机上所有容器的CPU,内存以及网络流量等数据。但是docker stats命令的缺点就是统计的只是当前宿主机的所有容器，而获取的监控数据是实时的，没有地方存储,也没有报警功能。
docker stats 而Scout、Sysdig Cloud、Data Dog虽然都提供了较完善的服务，但是它们都是托管的服务而且都收费，Sensu Monitoring Framework集成度较高，也免费，但是部署过于复杂。综合考虑，我们选择了CAdvisor做容器监控工具。
CAdvisor谷歌出品，优点是开源产品，监控指标齐全，部署方便，而且有官方的docker镜像。缺点是集成度不高，默认只在本地保存2分钟数据。不过可以加上InfluxDB存储数据，对接Grafana展示图表，比较便利地搭建好了容器监控系统，数据收集和图表展示效果良好，对系统性能也几乎没有什么影响。
CAdvisor CAdvisor是一个容器资源监控工具,包括容器的内存,CPU,网络IO,磁盘IO等监控,同时提供了一个WEB页面用于查看容器的实时运行状态。CAdvisor默认存储2分钟的数据,而且只是针对单物理机。不过，CAdvisor提供了很多数据集成接口,支持InfluxDB,Redis,Kafka,Elasticsearch等集成,可以加上对应配置将监控数据发往这些数据库存储起来。
CAdvisor功能主要有两点：
展示Host和容器两个层次的监控数据。
展示历史变化数据。
InfluxDB InfluxDB是用Go语言编写的一个开源分布式时序、事件和指标数据库,无需外部依赖。
前面说到,CAdvisor默认只在本机保存最近2分钟的数据，为了持久化存储数据和统一收集展示监控数据，需要将数据存储到InfluxDB中。InfluxDB是一个时序数据库,专门用于存储时序相关数据，很适合存储CAdvisor的数据。而且，CAdvisor本身已经提供了InfluxDB的集成方法，丰启动容器时指定配置即可。
InfluxDB主要功能:
基于时间序列,支持与时间有关的相关函数(如最大、最小、求和等);
可度量性:你可以实时对大量数据进行计算;
基于事件:它支持任意的事件数据;
InfluxDB主要特点:
无结构(无模式);
可以是任意数量的列;
可拓展的;
支持min,max,sum,count,mean,median等一系列函数,方便统计;
原生的HTTP支持,内置HTTP API;
强大的类SQL语法;
自带管理界面,方便使用
Granfana Grafana是一个开源的数据监控分析可视化平台,支持多种数据源配置(支持的数据源包括InfluxDB,MySQL,Elasticsearch,OpenTSDB,Graphite等)和丰富的插件及模板功能,支持图表权限控制和报警。
Grafan主要特性:
灵活丰富的图形化选项
可以混合多种风格
支持白天和夜间模式
多个数据源
CAdvisor+InfluxDB+Granfana CAdvisor:负责收集容器的随时间变化的数据
InfluxDB:负责存储时序数据
Grafana:负责分析和展示时序数据
安装部署 部署InfluxDB服务 docker run -d --name influxdb -p 8086:8086 \ -v /data/influxdb:/var/lib/influxdb \ --hostname=influxdb \ influxdb 说明：</description></item><item><title>Docker进阶-资源管理Swarm+Portainer</title><link>https://xueyaoblog.on-fleek.app/post/2019/docker-guide-swarm-portainer/</link><pubDate>Fri, 07 Sep 2018 12:13:29 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2019/docker-guide-swarm-portainer/</guid><description>Docker Swarm资源管理 Docker Swarm是Docker官方三剑客项目之一，提供Docker容器集群服务，是Docker官方对容器云生态进行支持的核心方案。
使用它，用户可以将多个Docker主机封装为单个大型的虚拟Docker主机，快速打造一套容器云平台。
注意：Docker1.12.0之后版本，Swarm模块已经内嵌入Docker引擎，成为Docker子命令docker swarm,绝大多用户已经开始使用Swarm模块，Docker引擎API已经删除Docker Swarm。
基本概念 Swarm是使用SwarmKit构建的Docker引擎内置(原生)的集群管理和编排工具。使用Swarm集群之前需要了解以下几个概念。
节点 运行Docker的主机可以主动初始化一个Swarm集群或者加入一个已存在的Swarm集群，这样运行Docker的主机就成为一个Swarm集群的节点(node)。
节点分为管理(manager)节点和工作(worker)节点。
管理节点用于Swarm集群的管理，docker swarm集合基本只能在管理节点执行。
工作节点是任务执行节点，管理节点将服务(service)下发至工作节点执行。
集群中管理节点与工作节点的关系
服务和任务 任务(Task)是Swarm中的最小的调度单位，目前来说就是一个单一的容器。
服务(Services)是指一组任务的集合，服务定义了任务的属性。
服务有两种模式：
replicated services 按照一定规则在各个工作节点上运行指定个数的任务。
global services每个工作节点运行一个任务
两个模式通过docker service create的&amp;ndash;mode参数指定
容器、任务、服务的关系
创建Swarm集群 了解Swarm集群由管理节点和工作节点组成后，我们创建一个包含一个管理节点和两个工作节点的最小Swarm集群。
初始化集群 使用docker swarm init在本地初始化一个Swarm集群。
docker swarm init --advertise-addr 192.168.1.1 如果你的Docker主机有多个网段，拥有多个IP，必须使用&amp;ndash;advertise-addr指定IP。执行docker swarm init命令的节点自动成为管理节点。
注意：使用docker swarm init
增加工作节点 在另外两台服务器上执行上一步创建管理节点时候的输出的加入swarm集群的全集
docker swarm join \ --token SWMTKN-1-3pu6hszjas19xyp7ghgosyx9k8atbfcr8p2is99znpy26u2lkl-1awxwuwd3z9j1z3puu7rcgdbx \ 192.168.1.1:2377 查看集群 在管理节点使用docker node ls查看集群。
docker node ls 部署服务 使用docker service命令来管理Swarm集群中的服务，该命令只能在管理节点运行。
新建服务 在创建好的Swarm集群中运行nginx服务</description></item><item><title>EasyUI-表单combobox下拉框回显</title><link>https://xueyaoblog.on-fleek.app/post/2017/bug-easyui-combobox/</link><pubDate>Fri, 01 Dec 2017 12:11:57 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2017/bug-easyui-combobox/</guid><description>EasyUI是基于Jquery开发的前端框架，适用于各个网站的后台页面，它提供多种丰富的功能，其中表单就有许多的功能。
问题 表单的修改功能，可以用EasyUI中的内置方法load来回显数据，但是，下拉框combobox却不能正确回显数据，通过百度搜索了许多相似的问题，网上给出的答应都是好多年前的，不适用于现在的版本。
解决方法 问了我的良师益友，他告诉我，EasyUI就为了combobox提供了setValue方法，来解决下拉框的回显问题
/** #cc 下拉框的name值 setValue 方法名 101 下拉框选择的value值 */$(&amp;#34;#cc&amp;#34;).combobox(&amp;#34;setValue&amp;#34;,&amp;#34;101&amp;#34;);</description></item><item><title>Ehcache缓存简单使用</title><link>https://xueyaoblog.on-fleek.app/post/2017/java-cache-ehcache-use/</link><pubDate>Sat, 25 Nov 2017 12:10:42 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2017/java-cache-ehcache-use/</guid><description>SPRING整合EHCACHE 1.引入坐标 pom.xml
&amp;lt;!-- ehcache的缓存框架 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;net.sf.ehcache&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;ehcache-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.6.10&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- spring整合第三方框架的 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-context-support&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 2.配置Ehcache ehcache.xml
&amp;lt;ehcache xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xsi:noNamespaceSchemaLocation=&amp;#34;../config/ehcache.xsd&amp;#34;&amp;gt; &amp;lt;!-- 硬盘上缓存的临时目录 --&amp;gt; &amp;lt;diskStore path=&amp;#34;java.io.tmpdir&amp;#34;/&amp;gt; &amp;lt;!-- maxElementsInMemory:内存中最大存放的元素的个数 eternal：是否永生，默认是false timeToIdleSeconds：发呆闲置的时间，超过该时间，被清除，单位秒 timeToLiveSeconds：存活的事件，超过该时间被清除 maxElementsOnDisk：如果内存满了，溢出到硬盘上的临时目录中的存放的元素的个数 diskExpiryThreadIntervalSeconds：轮询时间，巡视组 memoryStoreEvictionPolicy：内存对象的清理策略，如果满了，怎么办? 策略有三个：LRU、LFU、FIFO LRU:最少使用被清理，次数 LFU：时间，闲置最长的时间 FIFO：管道策略，先进先出 --&amp;gt; &amp;lt;defaultCache maxElementsInMemory=&amp;#34;10000&amp;#34; eternal=&amp;#34;false&amp;#34; timeToIdleSeconds=&amp;#34;120&amp;#34; timeToLiveSeconds=&amp;#34;120&amp;#34; maxElementsOnDisk=&amp;#34;10000000&amp;#34; diskExpiryThreadIntervalSeconds=&amp;#34;120&amp;#34; memoryStoreEvictionPolicy=&amp;#34;LRU&amp;#34;&amp;gt; &amp;lt;persistence strategy=&amp;#34;localTempSwap&amp;#34;/&amp;gt; &amp;lt;/defaultCache&amp;gt; &amp;lt;!-- Spring整合的菜单缓存 --&amp;gt; &amp;lt;cache name=&amp;#34;project_menu_cache&amp;#34; maxElementsInMemory=&amp;#34;10000&amp;#34; eternal=&amp;#34;false&amp;#34; timeToIdleSeconds=&amp;#34;120&amp;#34; timeToLiveSeconds=&amp;#34;120&amp;#34; maxElementsOnDisk=&amp;#34;10000000&amp;#34; diskExpiryThreadIntervalSeconds=&amp;#34;120&amp;#34; memoryStoreEvictionPolicy=&amp;#34;LRU&amp;#34;&amp;gt; &amp;lt;persistence strategy=&amp;#34;localTempSwap&amp;#34;/&amp;gt; &amp;lt;/cache&amp;gt; &amp;lt;/ehcache&amp;gt; 3.</description></item><item><title>Quartz作业调度的入门使用</title><link>https://xueyaoblog.on-fleek.app/post/2017/java-quartz-guide/</link><pubDate>Tue, 14 Nov 2017 12:09:41 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2017/java-quartz-guide/</guid><description>概念 1.Job
表示一个工作，要执行的具体的内容。此接口中只有一个方法
2.JobDetail
JobDetail表示一个具体的可执行的调度程序，Job是这个可执行调度程序所要执行的内容
3.Trigger
Trigger代表一个调度参数的配置
4.Scheduler
Scheduler代表一个调度容器，一个调度容器中可以注册多个JobDetail和Trigger.
说明：
编写job实现业务，要做什么具体事情 使用JobDetail包装job，是任务对象，可以被调度 使用Trigger定制什么时候去调用某任务对象 使用Scheduler结合任务对象和触发器对象 第一个任务 1.引入依赖坐标
pom.xml
&amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.quartz-scheduler&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;quartz&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.2.3&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.quartz-scheduler&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;quartz-jobs&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.2.3&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- slf4j log4j --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;slf4j-log4j12&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.7.7&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; 2.简单测试类
QuartzTest.java
package me.xueyao.quartz.test; import org.junit.Test; import org.quartz.Scheduler; import org.quartz.impl.StdSchedulerFactory; /** * @author XueYao * @date 2017-11-26 */ public class QuartzTest { //quartz容器启动和关闭 @Test public void testFirst() throws Exception { //Scheduler scheduler = StdSchedulerFactory.</description></item><item><title>AngularJS动态特效之验证码按钮倒计时</title><link>https://xueyaoblog.on-fleek.app/post/2017/angularjs-effect-verification-code/</link><pubDate>Sat, 11 Nov 2017 12:08:39 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2017/angularjs-effect-verification-code/</guid><description>功能需求 当用户注册或者找回密码时，输入注册的手机号发送验证码到手机中，点击发送验证码按钮倒计时这个功能是如何实现呢？
效果如下 表单代码如下 &amp;lt;div class=&amp;#34;signup&amp;#34; ng-app=&amp;#34;signupApp&amp;#34; ng-controller=&amp;#34;signupCtrl&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;col-md-9 signupbox&amp;#34;&amp;gt; &amp;lt;form id=&amp;#34;signupForm&amp;#34; action=&amp;#34;customer_regist.action&amp;#34; method=&amp;#34;post&amp;#34; class=&amp;#34;form col-md-6&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;form-group&amp;#34;&amp;gt; &amp;lt;label for=&amp;#34;inputaccount&amp;#34; class=&amp;#34;col-sm-3 control-label&amp;#34;&amp;gt; &amp;lt;b&amp;gt;*&amp;lt;/b&amp;gt;验证码&amp;lt;/label&amp;gt; &amp;lt;div class=&amp;#34;col-sm-5&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;checkcode&amp;#34; class=&amp;#34;form-control&amp;#34; id=&amp;#34;inputaccount&amp;#34; placeholder=&amp;#34;请输入验证码&amp;#34;&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;col-sm-3 song&amp;#34;&amp;gt; &amp;lt;button type=&amp;#34;button&amp;#34; id=&amp;#34;checkCode&amp;#34; class=&amp;#34;btn btn-default&amp;#34; ng-bind=&amp;#34;checkcodemsg&amp;#34; ng-click=&amp;#34;getCheckCode()&amp;#34;&amp;gt;获取验证码&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;form&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; JS代码如下 &amp;lt;!--验证码倒计时--&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34;&amp;gt; angular.module(&amp;#34;signupApp&amp;#34;, []) .controller(&amp;#34;signupCtrl&amp;#34;, [&amp;#34;$scope&amp;#34;, function ($scope) { //按钮初始化的名字 $scope.checkcodemsg = &amp;#34;获取验证码&amp;#34;; //倒计时变量，默认60秒 var second = 5; //定时器对象 var secondInterval = undefined; //是否允许发送验证码的标识 var enableFlag = true; //获取验证码点击事件 $scope.</description></item><item><title>Spring的AOP编程</title><link>https://xueyaoblog.on-fleek.app/post/2017/spring-aop/</link><pubDate>Mon, 16 Oct 2017 12:06:56 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2017/spring-aop/</guid><description>AOP为Aspect Oriented Programming(面向切面编程)
AOP的好处：在不修改源代码的情况下，可以实现功能的增强
JDK动态代理 缺点：只能针对实现了接口的类实现代理
/** * Jdk的动态代理 * @author kevin */ public class JdkProxy implements InvocationHandler{ //要代理的对象 private CustomerDao customerDao; public JdkProxy(CustomerDao customerDao){ this.customerDao = customerDao; } /** * 生成代理对象的方法 * @return */ public CustomerDao createProxy(){ CustomerDao proxy = (CustomerDao) Proxy.newProxyInstance(customerDao.getClass().getClassLoader(), customerDao.getClass().getInterfaces(), this); return proxy; } /** * 增强的方法 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(&amp;#34;权限校验...&amp;#34;); return method.invoke(customerDao, args); } } //编写测试代码： @Test public void test(){ CustomerDao customerDao = new CustomerDaoImpl(); JdkProxy jdkProxy = new JdkProxy(customerDao); CustomerDao proxy = jdkProxy.</description></item><item><title>AJAX省市县三级联动的实现</title><link>https://xueyaoblog.on-fleek.app/post/2017/js-effect-third-linkage/</link><pubDate>Thu, 14 Sep 2017 12:04:08 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2017/js-effect-third-linkage/</guid><description>省市县数据
本例子中省市县数据保存在MySQL数据库中,部分数据截图如下:
从数据库中读取数据
1、导入需要的jar包
2、连接池配置文件
&amp;lt;c3p0-config&amp;gt; &amp;lt;!-- 默认配置，如果没有指定则使用这个配置 --&amp;gt; &amp;lt;default-config&amp;gt; &amp;lt;property name=&amp;#34;driverClass&amp;#34;&amp;gt;com.mysql.jdbc.Driver&amp;lt;/property&amp;gt; &amp;lt;property name=&amp;#34;jdbcUrl&amp;#34;&amp;gt;jdbc:mysql://127.0.0.1:3306/test&amp;lt;/property&amp;gt; &amp;lt;property name=&amp;#34;user&amp;#34;&amp;gt;root&amp;lt;/property&amp;gt; &amp;lt;property name=&amp;#34;password&amp;#34;&amp;gt;数据库密码&amp;lt;/property&amp;gt; &amp;lt;property name=&amp;#34;checkoutTimeout&amp;#34;&amp;gt;30000&amp;lt;/property&amp;gt; &amp;lt;property name=&amp;#34;idleConnectionTestPeriod&amp;#34;&amp;gt;30&amp;lt;/property&amp;gt; &amp;lt;property name=&amp;#34;initialPoolSize&amp;#34;&amp;gt;10&amp;lt;/property&amp;gt; &amp;lt;property name=&amp;#34;maxIdleTime&amp;#34;&amp;gt;30&amp;lt;/property&amp;gt; &amp;lt;property name=&amp;#34;maxPoolSize&amp;#34;&amp;gt;100&amp;lt;/property&amp;gt; &amp;lt;property name=&amp;#34;minPoolSize&amp;#34;&amp;gt;10&amp;lt;/property&amp;gt; &amp;lt;property name=&amp;#34;maxStatements&amp;#34;&amp;gt;200&amp;lt;/property&amp;gt; &amp;lt;user-overrides user=&amp;#34;test-user&amp;#34;&amp;gt; &amp;lt;property name=&amp;#34;maxPoolSize&amp;#34;&amp;gt;10&amp;lt;/property&amp;gt; &amp;lt;property name=&amp;#34;minPoolSize&amp;#34;&amp;gt;1&amp;lt;/property&amp;gt; &amp;lt;property name=&amp;#34;maxStatements&amp;#34;&amp;gt;0&amp;lt;/property&amp;gt; &amp;lt;/user-overrides&amp;gt; &amp;lt;/default-config&amp;gt; &amp;lt;/c3p0-config&amp;gt; 3、JDBCUtils工具类文件
通用JDBCUtils工具类文件,使用时直接引入
package org.xueyao.ajax.utils; import java.sql.Connection; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; import javax.sql.DataSource; import org.apache.tomcat.jni.Thread; import com.mchange.v2.c3p0.ComboPooledDataSource; public class JDBCUtils { private static ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource(); //使用ThreadLocal存取删链接对象 private static ThreadLocal&amp;lt;Connection&amp;gt; local = new ThreadLocal&amp;lt;&amp;gt;(); public static Connection getConnection() throws SQLException{ return comboPooledDataSource.</description></item><item><title>Javamail简单使用案例</title><link>https://xueyaoblog.on-fleek.app/post/2017/java-email-simple-use-example/</link><pubDate>Wed, 13 Sep 2017 12:02:47 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2017/java-email-simple-use-example/</guid><description>邮件开发环境搭建 邮件服务器 易邮邮件服务器 配置如下 邮件客户端 Foxmail 配置如下 使用Javamail发送邮件 1、下载
javamail-samples.zip javax.mail.jar 官网地址http://www.oracle.com/technetwork/java/javamail/index.html
2、使用javamail
发送到本地的邮件中
package org.xueyao.email; import java.util.Date; import java.util.Properties; import javax.mail.Message; import javax.mail.Session; import javax.mail.Transport; import javax.mail.internet.InternetAddress; import javax.mail.internet.MimeMessage; public class MailUtils { /** * 发送邮件 * @param to 接收邮件的地址 * @param subject 邮件主题 * @param msgText 邮件内容 */ public static void send(String to, String subject, String msgText) { //发邮件的地址 String from = &amp;#34;admin@flowstone.com&amp;#34;; //邮件发送服务器地址 String host = &amp;#34;localhost&amp;#34;; //是否开启debug模式 boolean debug = true; // 设置发送邮件的配置信息 Properties props = new Properties(); props.</description></item><item><title>JS小例子之二级联动</title><link>https://xueyaoblog.on-fleek.app/post/2017/js-effect-second-linkage/</link><pubDate>Sat, 26 Aug 2017 11:30:20 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2017/js-effect-second-linkage/</guid><description>联动原理 当用户点击省级的下拉选项,选择所在省,下一个下拉选项里的选项,则变成用户选择省下的所有市的信息,不会出现其它省市的信息.
省市数据 把省市数据,保存在js文件中,以json形式保存,以便读取,下面代码使用部分数据,不影响效果
var china = [ { &amp;#34;p_name&amp;#34;: &amp;#34;吉林省&amp;#34;, &amp;#34;p_id&amp;#34;: &amp;#34;jl&amp;#34;, &amp;#34;cities&amp;#34;: [ { &amp;#34;c_name&amp;#34;: &amp;#34;长春&amp;#34;, &amp;#34;c_id&amp;#34;: &amp;#34;cc&amp;#34; }, { &amp;#34;c_name&amp;#34;: &amp;#34;四平&amp;#34;, &amp;#34;c_id&amp;#34;: &amp;#34;sp&amp;#34; }, { &amp;#34;c_name&amp;#34;: &amp;#34;通化&amp;#34;, &amp;#34;c_id&amp;#34;: &amp;#34;th&amp;#34; }, { &amp;#34;c_name&amp;#34;: &amp;#34;松原&amp;#34;, &amp;#34;c_id&amp;#34;: &amp;#34;sy&amp;#34; } ] }, { &amp;#34;p_name&amp;#34;: &amp;#34;辽宁省&amp;#34;, &amp;#34;p_id&amp;#34;: &amp;#34;ln&amp;#34;, &amp;#34;cities&amp;#34;: [ { &amp;#34;c_name&amp;#34;: &amp;#34;沈阳&amp;#34;, &amp;#34;c_id&amp;#34;: &amp;#34;sy&amp;#34; }, { &amp;#34;c_name&amp;#34;: &amp;#34;大连&amp;#34;, &amp;#34;c_id&amp;#34;: &amp;#34;dl&amp;#34; }, { &amp;#34;c_name&amp;#34;: &amp;#34;抚顺&amp;#34;, &amp;#34;c_id&amp;#34;: &amp;#34;fs&amp;#34; }, { &amp;#34;c_name&amp;#34;: &amp;#34;铁岭&amp;#34;, &amp;#34;c_id&amp;#34;: &amp;#34;tl&amp;#34; } ] }, { &amp;#34;p_name&amp;#34;: &amp;#34;山东省&amp;#34;, &amp;#34;p_id&amp;#34;: &amp;#34;sd&amp;#34;, &amp;#34;cities&amp;#34;: [ { &amp;#34;c_name&amp;#34;: &amp;#34;济南&amp;#34;, &amp;#34;c_id&amp;#34;: &amp;#34;jn&amp;#34; }, { &amp;#34;c_name&amp;#34;: &amp;#34;青岛&amp;#34;, &amp;#34;c_id&amp;#34;: &amp;#34;qd&amp;#34; }, { &amp;#34;c_name&amp;#34;: &amp;#34;威海&amp;#34;, &amp;#34;c_id&amp;#34;: &amp;#34;wh&amp;#34; }, { &amp;#34;c_name&amp;#34;: &amp;#34;烟台&amp;#34;, &amp;#34;c_id&amp;#34;: &amp;#34;yt&amp;#34; } ] }, { &amp;#34;p_name&amp;#34;: &amp;#34;上海市&amp;#34;, &amp;#34;p_id&amp;#34;: &amp;#34;sh&amp;#34;, &amp;#34;cities&amp;#34;: [ { &amp;#34;c_name&amp;#34;: &amp;#34;闵行区&amp;#34;, &amp;#34;c_id&amp;#34;: &amp;#34;mh&amp;#34; }, { &amp;#34;c_name&amp;#34;: &amp;#34;徐汇区&amp;#34;, &amp;#34;c_id&amp;#34;: &amp;#34;xh&amp;#34; }, { &amp;#34;c_name&amp;#34;: &amp;#34;黄浦区&amp;#34;, &amp;#34;c_id&amp;#34;: &amp;#34;hp&amp;#34; }, { &amp;#34;c_name&amp;#34;: &amp;#34;浦东新区&amp;#34;, &amp;#34;c_id&amp;#34;: &amp;#34;pd&amp;#34; } ] } ]; 获取省市数据 通过js dom编程读取省市数据,把省市数据读取到对应的select选项中.</description></item><item><title>关于equals()方法两边变量如何放置</title><link>https://xueyaoblog.on-fleek.app/post/2017/java-how-use-equals/</link><pubDate>Fri, 07 Jul 2017 11:29:08 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2017/java-how-use-equals/</guid><description> 两个变量放置位置 如果是两个都是变量，可以放在equals任意一边，没有区别
常量、变量放置位置 如果有一个是常量，equals()方法在使用时，建议equals()方法前面放常量。因为equals()是Object类中定义的，任何对象都可以调用equals()方法，但是，如果对象的值是null的话，会引起空指针异常。
如果变量放在前面也就相当调用变量的equals()方法，变量为空时，就会报空指针异常。所以把常量放在equals()方法前面，是非常好的习惯。
再者，如果变量放在equals()方法的括号内，变量为空时，equals()方法和null做比较，不会出现异常。
如下：
//constant为常量，variable为变量constant.equals(variable); //建议这样使用variable.equals(constant); //不建议使用，当变量为空时，会出现空指针异常</description></item><item><title>Java Random入门</title><link>https://xueyaoblog.on-fleek.app/post/2017/java-random-guide/</link><pubDate>Sun, 02 Jul 2017 11:28:02 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2017/java-random-guide/</guid><description>什么是Random？ 当用户要产生一个随机数，java本身提供了丰富的Random类。用户可以根据需求创建Random对象，根据Random类下的方法创建特殊的随机数。
如何创建Random?
首先用户要创建一个Random对象
Random random = new Random(); 不过在使用对象之前，要导入对应的包
import java.util.Random; 当用户要创建一个整型的随机数，范围在0-100之间
/* 创建随机数时，如nextInt(m),里面的范围有一定的规律，如果用户要创建一个m-n(包括m,n)的随机数时， 公式：nextInt(n-m+1)+m;如果用户要创建一个m-n(不包括m,n)的随机数时，公式：nextInt(n-m); */ int num = random.nextInt(101); 用户可以创建各种类型的随机数，只需要使用对应的方法，即可生成。</description></item><item><title>GitHub Pages二级域名的配置</title><link>https://xueyaoblog.on-fleek.app/post/2017/github-page-config-sub-domain/</link><pubDate>Fri, 03 Feb 2017 11:26:31 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2017/github-page-config-sub-domain/</guid><description> 域名配置指南 首先创建一个新的仓库，并在设置中设置GitHub Pages的Source从master主分支上构建，点击保存，如下图所示:
并在Custom domain 里填写自定义的二级域名，如下图所示:
在你的域名注册商那里设置域名的DNS,类型CNAME,具体配置如下:
把写好的代码同步到创建的仓库中，通过浏览器访问二级域名，效果如下：
注意此二级域名的一级域名必须解析到自己flowstone.github.io下，如下图所示：</description></item><item><title>2017年小目标</title><link>https://xueyaoblog.on-fleek.app/post/2017/year-2017-project/</link><pubDate>Sun, 01 Jan 2017 11:25:32 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2017/year-2017-project/</guid><description> 看12本书籍 每天更新github 每天5000步</description></item><item><title>Ajax自定义日历</title><link>https://xueyaoblog.on-fleek.app/post/2016/js-custom-calendar/</link><pubDate>Tue, 27 Sep 2016 22:19:51 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2016/js-custom-calendar/</guid><description>需求分析 在一些购物网站中，都会有促销活动，这些活动都在日历上标注出来，如何通过Ajax让日历
通过读取数据库中的信息，正确的把促销活动标注在日历上，本文通过自定义日历来实现这个问题。
技术难点 日历的布局
日历的初始化
日历的动态变化
日历的促销定制
实现方法 1、 先创建一个固定的日历，效果如下
html代码如下
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt; &amp;lt;style type=&amp;#34;text/css&amp;#34;&amp;gt; * {margin: 0; padding: 0;} body {font-size: 13px;} .calendar {width: 330px; margin: 0 auto;} .calendar .title { position: relative; width: 100%; height: 30px; line-height: 30px; background: #17a4eb; } .title div {position: absolute;} .prev {left: 10px; } .now {left: 40%;} .next {right: 10px;} input {height: 30px; width: 300px; margin: 100px 475px 0px;} table {width: 100%; border-collapse: collapse;} table th {border: 1px solid #ccc;} table td {text-align: center; border: 1px solid #ccc;} &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;calendar&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;title&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;prev&amp;#34;&amp;gt; &amp;lt;span&amp;gt;08&amp;lt;/span&amp;gt;月 &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;now&amp;#34;&amp;gt; &amp;lt;span&amp;gt;2016&amp;lt;/span&amp;gt;年 &amp;lt;span&amp;gt;09&amp;lt;/span&amp;gt;月 &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;next&amp;#34;&amp;gt; &amp;lt;span&amp;gt;10&amp;lt;/span&amp;gt;月 &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;table&amp;gt; &amp;lt;!</description></item><item><title>JS特效-轮播图</title><link>https://xueyaoblog.on-fleek.app/post/2016/js-effect-carousel/</link><pubDate>Sat, 17 Sep 2016 22:17:35 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2016/js-effect-carousel/</guid><description>效果如下 功能分析 每隔1秒换一张图片 鼠标移入停止切换、鼠标离开继续切换 鼠标移入到数字上面的时候,显示和数字对应的图片,并且停止切换,被选中的数字,背景显示橙色 鼠标离开数字,从该数字后面继续显示 代码如下 &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt; &amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34;&amp;gt; &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt; &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;&amp;#34;&amp;gt; &amp;lt;style type=&amp;#34;text/css&amp;#34;&amp;gt; div, img, ul, li { padding: 0px; margin: 0px; } .content { width: 480px; height: 300px; border: 1px solid red; margin: 100px auto; } img { width: 100%; height: 100%; padding-bottom: 10px; } ul li { list-style: none; float: left; border: 1px solid orange; height: 30px; width: 58px; text-align: center; line-height: 30px; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div class=&amp;#34;content&amp;#34;&amp;gt; &amp;lt;img src=&amp;#34;.</description></item><item><title>Cookie实例-保存用户登录时的用户名</title><link>https://xueyaoblog.on-fleek.app/post/2016/php-cookie-save-username/</link><pubDate>Fri, 19 Aug 2016 22:13:29 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2016/php-cookie-save-username/</guid><description>实现一个登录界面,记录用户名的信息,10小时内，不需要重新输入用户名的信息。(请使用Cookie完成)
界面代码如下
&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt; &amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;IE=edge&amp;#34;&amp;gt; &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt; &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;&amp;#34;&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;form action=&amp;#34;user.php?a=check&amp;#34; method=&amp;#39;post&amp;#39;&amp;gt; u: &amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#39;username&amp;#39; value=&amp;#34;&amp;lt;?php echo $username;?&amp;gt;&amp;#34;&amp;gt;&amp;lt;br/&amp;gt; p: &amp;lt;input type=&amp;#34;password&amp;#34; name=&amp;#39;password&amp;#39;&amp;gt;&amp;lt;br/&amp;gt; 是否保存用户名 &amp;lt;input type=&amp;#34;radio&amp;#34; value=&amp;#39;yes&amp;#39; name=&amp;#39;save&amp;#39;&amp;gt;保存10小时 &amp;lt;input type=&amp;#34;radio&amp;#34; value=&amp;#39;no&amp;#39; name=&amp;#39;save&amp;#39;&amp;gt;不保存&amp;lt;br/&amp;gt; &amp;lt;input type=&amp;#34;submit&amp;#34; value=&amp;#34;登录&amp;#34;&amp;gt; &amp;lt;/form&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt; 代码如下：
&amp;lt;?php header(&amp;#39;content-type:text/html;charset=utf-8&amp;#39;); $action = isset($_GET[&amp;#39;a&amp;#39;]) ? $_GET[&amp;#39;a&amp;#39;] :&amp;#39;login&amp;#39;; if ($action == &amp;#39;login&amp;#39;) { $username = &amp;#39;&amp;#39;; if (isset($_COOKIE[&amp;#39;username&amp;#39;])){ $username = $_COOKIE[&amp;#39;username&amp;#39;]; } require &amp;#39;myLogin.html&amp;#39;; } elseif ($action == &amp;#39;check&amp;#39;) { $username = isset($_POST[&amp;#39;username&amp;#39;]) ?</description></item><item><title>Git入门</title><link>https://xueyaoblog.on-fleek.app/post/2016/git-guide/</link><pubDate>Mon, 18 Jul 2016 22:08:00 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2016/git-guide/</guid><description>安装 下载git OSX版 下载git Windows版 下载git Linux版 创建新仓库 创建新文件夹，打开，然后执行
git init 以创建新的git仓库
克隆仓库 创建一个本地仓库的克隆版本：
git clone /path/to/repository 如果要克隆服务器上的仓库，你的命令会是这个样子：
git clone username@host:/path/to/repository 添加与提交 git add &amp;#34;filename&amp;#34;git add * git add . 这是git基本工作流程的第一步;使用如下命令以实际提交改动：
git commit -m &amp;#39;代码提交信息&amp;#39; 推送仓库 改动提交到远端仓库：
git push origin master 可以把master 换成你想要推送的任何分支。
如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：
git remote add origin &amp;lt;server&amp;gt; 更新与合并 要更新你的本地仓库至最新改动，执行：
git pull 以在你的工作目录中 获取（fetch） 并 合并（merge） 远端的改动。
要合并其他分支到你的当前分支（例如 master），执行：
git merge &amp;lt;branch&amp;gt; 两种情况下，git 都会尝试去自动合并改动。不幸的是，自动合并并非次次都能成功，并可能导致 冲突（conflicts）。 这时候就需要你修改这些文件来合并这些冲突（conflicts）了。改完之后，你需要执行如下命令以将它们标记为合并成功：
git add &amp;lt;filename&amp;gt; 在合并改动之前，也可以使用如下命令查看：</description></item><item><title>PHP实现分页功能</title><link>https://xueyaoblog.on-fleek.app/post/2016/php-set-pagehelp/</link><pubDate>Sat, 16 Jul 2016 22:01:31 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2016/php-set-pagehelp/</guid><description> 如何实现分页功能 1.代码如下
$total = mysql_num_rows($res1); //页面大小 $pagesize = 3; //页面的值 $page = isset($_GET[&amp;#39;page&amp;#39;]) ?$_GET[&amp;#39;page&amp;#39;] : 1; //页面最大数目 $maxpage = ceil($total/$pagesize); //偏移量 $offset = ($page-1)*$pagesize; $sql = &amp;#34;select * from mess_info limit {$offset},{$pagesize}&amp;#34;; &amp;lt;ul class=&amp;#34;pager&amp;#34;&amp;gt; &amp;lt;li class=&amp;#34;previous&amp;#34;&amp;gt;&amp;lt;a href=&amp;#34;list.php?page=1&amp;#34;&amp;gt; 首页&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;list.php?page=&amp;lt;?php echo $page&amp;lt;=1 ? $page : $page-1;?&amp;gt;&amp;#34;&amp;gt;上一页&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;list.php?page=&amp;lt;?php echo $page&amp;gt;=$maxpage ? $maxpage : $page+1;?&amp;gt;&amp;#34;&amp;gt;下一页&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li class=&amp;#34;next&amp;#34;&amp;gt;&amp;lt;a href=&amp;#34;list.php?page=&amp;lt;?php echo $maxpage;?&amp;gt;&amp;#34;&amp;gt;末页 &amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt;</description></item><item><title>安装WAMP开发环境</title><link>https://xueyaoblog.on-fleek.app/post/2016/install-wamp-env/</link><pubDate>Sat, 16 Jul 2016 21:52:27 +0000</pubDate><guid>https://xueyaoblog.on-fleek.app/post/2016/install-wamp-env/</guid><description>如何安装WAMP开发环境 一.Apache安装 以管理员方式运行cmd 在apache\bin目录下运行 httpd -k install 安装成功后配置apache的配置文件 将配置文件中apache的安装目录改成你apache的位置 并修改serverName服务地址为localhost 配置后，重新启动apache服务 httpd -k start 二.PHP安装 1.将php处理模块和apache整合到一起，修改httpd.conf
LoadModule php5_module &amp;#34;{php路径}/php5.6.16/php5apache2_4.dll&amp;#34; &amp;lt;FilesMatch \.php$&amp;gt; SetHandler application/x-httpd-php &amp;lt;/FilesMatch&amp;gt; PHPIniDir &amp;#34;{php路径}/php5.6.16/&amp;#34; 2.将php.ini-deployment 改成 php.ini 启用开发模式
3.开启dll库
extension=php_bz2.dll extension=php_curl.dll extension=php_mbstring.dll extension=php_mysql.dll extension=php_mysqli.dll 在phi.ini 中指定扩展模块路径
extension_dir = &amp;#34;{php路径}/php-5.6.16/ext&amp;#34; 重新apache服务
三.mysql安装 典型安装-细节配置-并发设置-端口设置-字符集-服务名-密码配置</description></item></channel></rss>